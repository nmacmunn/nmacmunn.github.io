import{S as Hn,i as Sn,s as Cn,k as l,q as i,a as E,l as f,m,r as a,h as e,c as P,n as H,b as o,D as t,u as zn,I as Ee,y as S,K as Qn,z as C,A as M,g as L,d as z,B as Q,O as Vn}from"../chunks/index.4711a160.mjs";import{S as ke,R as Nn,A as Mt}from"../chunks/resources.cfbab304.mjs";import{A as Fn}from"../chunks/article.06c607fb.mjs";import{S as X}from"../chunks/snippet.e1d427ae.mjs";function Dn(j){let r,w;return{c(){r=l("meta"),this.h()},l(y){r=f(y,"META",{property:!0,content:!0}),this.h()},h(){H(r,"property","og:image"),H(r,"content",w="https://neil.macmunn.com/"+j[3])},m(y,u){o(y,r,u)},p(y,u){u&8&&w!==(w="https://neil.macmunn.com/"+y[3])&&H(r,"content",w)},d(y){y&&e(r)}}}function Gn(j){let r,w,y,u,v,c,$,R,A,x,q,_,d,I,b=j[3]&&Dn(j);return{c(){r=l("title"),w=i(j[0]),y=E(),u=l("meta"),v=E(),c=l("meta"),$=E(),R=l("meta"),x=E(),q=l("meta"),_=E(),b&&b.c(),d=E(),I=l("meta"),this.h()},l(p){r=f(p,"TITLE",{});var g=m(r);w=a(g,j[0]),g.forEach(e),y=P(p),u=f(p,"META",{name:!0,content:!0}),v=P(p),c=f(p,"META",{property:!0,content:!0}),$=P(p),R=f(p,"META",{property:!0,content:!0}),x=P(p),q=f(p,"META",{property:!0,content:!0}),_=P(p),b&&b.l(p),d=P(p),I=f(p,"META",{property:!0,content:!0}),this.h()},h(){H(u,"name","description"),H(u,"content",j[1]),H(c,"property","og:title"),H(c,"content",j[0]),H(R,"property","og:url"),H(R,"content",A="https://neil.macmunn.com/posts/"+j[2]),H(q,"property","og:description"),H(q,"content",j[1]),H(I,"property","og:type"),H(I,"content","article")},m(p,g){o(p,r,g),t(r,w),o(p,y,g),o(p,u,g),o(p,v,g),o(p,c,g),o(p,$,g),o(p,R,g),o(p,x,g),o(p,q,g),o(p,_,g),b&&b.m(p,g),o(p,d,g),o(p,I,g)},p(p,[g]){g&1&&zn(w,p[0]),g&2&&H(u,"content",p[1]),g&1&&H(c,"content",p[0]),g&4&&A!==(A="https://neil.macmunn.com/posts/"+p[2])&&H(R,"content",A),g&2&&H(q,"content",p[1]),p[3]?b?b.p(p,g):(b=Dn(p),b.c(),b.m(d.parentNode,d)):b&&(b.d(1),b=null)},i:Ee,o:Ee,d(p){p&&e(r),p&&e(y),p&&e(u),p&&e(v),p&&e(c),p&&e($),p&&e(R),p&&e(x),p&&e(q),p&&e(_),b&&b.d(p),p&&e(d),p&&e(I)}}}function Wn(j,r,w){let{title:y}=r,{description:u}=r,{slug:v}=r,{image:c=void 0}=r;return j.$$set=$=>{"title"in $&&w(0,y=$.title),"description"in $&&w(1,u=$.description),"slug"in $&&w(2,v=$.slug),"image"in $&&w(3,c=$.image)},[y,u,v,c]}class Kn extends Hn{constructor(r){super(),Sn(this,r,Wn,Gn,Cn,{title:0,description:1,slug:2,image:3})}}const Mn=`import express, { type Request, type Response } from "express";

// Pet database
const pets = [{ name: "Garfield" }, { name: "Odie" }];

// Create express app
const app = express();

// Define routes
app.get("/pets/:petId", (req: Request, res: Response) => {
  const id = parseInt(req.params.petId, 10);
  const pet = pets[id];
  if (pet) {
    res.json(pet);
  } else {
    res.status(404).json("Pet not found");
  }
});

// Start server
app.listen(3000);
`,Yn=`import express from "express";
import type { OpenApiRequestHandler } from "./openapi-express";
import type { operations } from "./petstore";

// Pet database
const pets = [{ name: "Garfield" }, { name: "Odie" }];

// Create express app
const app = express();

// Define routes
app.get("/pets/:petId", ((req, res) => {
  const id = parseInt(req.params.petId, 10);
  const pet = pets[id];
  if (pet) {
    res.json({ id, ...pet });
  } else {
    res.status(404).json({ code: 404, message: "Pet not found" });
  }
}) satisfies OpenApiRequestHandler<operations["showPetById"]>);

// Start server
app.listen(3000);
`,Ln=`/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/pets/{petId}": {
    /** Info for a specific pet */
    get: operations["showPetById"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Pet: {
      /** Format: int64 */
      id: number;
      name: string;
      tag?: string;
    };
    Error: {
      /** Format: int32 */
      code: number;
      message: string;
    };
  };
  responses: never;
  parameters: never;
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Info for a specific pet */
  showPetById: {
    parameters: {
      path: {
        /** @description The id of the pet to retrieve */
        petId: string;
      };
    };
    responses: {
      /** @description Expected response to a valid request */
      200: {
        content: {
          "application/json": components["schemas"]["Pet"];
        };
      };
      /** @description unexpected error */
      default: {
        content: {
          "application/json": components["schemas"]["Error"];
        };
      };
    };
  };
}
`,Un=`openapi: "3.0.0"
info:
  version: 1.0.0
  title: Swagger Petstore
paths:
  /pets/{petId}:
    get:
      summary: Info for a specific pet
      operationId: showPetById
      tags:
        - pets
      parameters:
        - name: petId
          in: path
          required: true
          description: The id of the pet to retrieve
          schema:
            type: string
      responses:
        "200":
          description: Expected response to a valid request
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Pet"
        default:
          description: unexpected error
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/Error"
components:
  schemas:
    Pet:
      type: object
      required:
        - id
        - name
      properties:
        id:
          type: integer
          format: int64
        name:
          type: string
        tag:
          type: string
    Error:
      type: object
      required:
        - code
        - message
      properties:
        code:
          type: integer
          format: int32
        message:
          type: string
`,Jn=`interface RequestHandler<
  P = ParamsDictionary,
  ResBody = any,
  ReqBody = any,
  ReqQuery = ParsedQs,
  LocalsObj extends Record<string, any> = Record<string, any>
> {
  (
    req: Request<P, ResBody, ReqBody, ReqQuery, LocalsObj>,
    res: Response<ResBody, LocalsObj>,
    next: NextFunction
  ): void;
}
`,jn=`import type { RequestHandler } from "express";

export type ShowPetByIdHandler = RequestHandler<
  { petId: string },
  { id: number; name: string } | { error: { message: string } },
  undefined,
  undefined
>;

import type { OpenApiRequestHandler } from "./openapi-express";
import type { operations } from "./petstore";

export type ShowPetByIdHandler = OpenApiRequestHandler<
  operations["showPetById"]
>;
`,At=`import type { RequestHandler } from "express";

export type OpenApiRequestHandler<
  Operation,
  Locals extends Record<string, any> = Record<string, any>
> = RequestHandler<
  OpenApiPathParams<Operation>,
  OpenApiResponseBody<Operation>,
  OpenApiRequestBody<Operation>,
  OpenApiQueryParams<Operation>,
  Locals
>;

type OpenApiPathParams<Operation> = Property<
  Property<Operation, "parameters">,
  "path"
>;

/**
 * Get an object's property's type.
 */
type Property<T, K extends PropertyKey> = K extends keyof T ? T[K] : undefined;

type OpenApiRequestBody<Operation> = Properties<
  Property<Property<Operation, "requestBody">, "content">
>;

/**
 * Get the union of an object's properties' types or \`undefined\` if the object
 * has no properties.
 */
type Properties<T> = [T[keyof T]] extends [never] ? undefined : T[keyof T];

type OpenApiResponseBody<Operation> = Properties<
  Property<Properties<Property<Operation, "responses">>, "content">
>;

type OpenApiQueryParams<Operation> = MapToString<
  Property<Property<Operation, "parameters">, "query">
>;

/**
 * Converts an object's properties' types to string subtypes.
 */
type MapToString<T> = {
  [K in keyof T]: ToString<T[K]>;
};
/**
 * Converts a type to a string subtype.
 */
type ToString<T> = T extends string
  ? T
  : T extends boolean
  ? "true" | "false"
  : string;
`,Xn=`import type { RequestHandler } from "express";
import type { OpenApiRequestHandler } from "./openapi-express";
import type { operations } from "./petstore";

declare const expect: <T extends true>() => void;

type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y
  ? 1
  : 2
  ? true
  : false;

expect<
  Equal<
    OpenApiRequestHandler<operations["showPetById"]>,
    RequestHandler<
      { petId: string },
      | { id: number; name: string; tag?: string }
      | { code: number; message: string },
      undefined,
      undefined
    >
  >
>;
`;function Zn(j){let r,w,y,u,v,c,$,R,A,x,q,_,d,I,b,p,g;return u=new X({props:{lineNumbers:!0,scrollToEnd:!1,value:Mn}}),$=new Mt({props:{href:"https://www.openapis.org/",label:"OpenAPI"}}),_=new Mt({props:{href:"https://fastapi.tiangolo.com/",label:"FastAPI"}}),{c(){r=l("p"),w=i(`I was recently asked to provide API documentation for an unfamiliar
      Express API. It might've looked something like the ubiquitous pet store
      example.`),y=E(),S(u.$$.fragment),v=E(),c=l("p"),S($.$$.fragment),R=i(` is a popular specification
      for describing RESTful APIs that can be consumed by many tools to generate
      documentation, client code, and server code.`),A=E(),x=l("p"),q=i(`My first idea was to generate the API docs automatically from the code -
      an approach I'd used before with Python's `),S(_.$$.fragment),d=i(` framwework. Unfortunately, I wasn't able to find a tool that could generate
      OpenAPI specs from Express application code.`),I=E(),b=l("p"),p=i(`My next idea was to start with an OpenAPI specification and use it to
      type-check the code as well as generate documentation.`)},l(T){r=f(T,"P",{});var B=m(r);w=a(B,`I was recently asked to provide API documentation for an unfamiliar
      Express API. It might've looked something like the ubiquitous pet store
      example.`),B.forEach(e),y=P(T),C(u.$$.fragment,T),v=P(T),c=f(T,"P",{});var k=m(c);C($.$$.fragment,k),R=a(k,` is a popular specification
      for describing RESTful APIs that can be consumed by many tools to generate
      documentation, client code, and server code.`),k.forEach(e),A=P(T),x=f(T,"P",{});var s=m(x);q=a(s,`My first idea was to generate the API docs automatically from the code -
      an approach I'd used before with Python's `),C(_.$$.fragment,s),d=a(s,` framwework. Unfortunately, I wasn't able to find a tool that could generate
      OpenAPI specs from Express application code.`),s.forEach(e),I=P(T),b=f(T,"P",{});var h=m(b);p=a(h,`My next idea was to start with an OpenAPI specification and use it to
      type-check the code as well as generate documentation.`),h.forEach(e)},m(T,B){o(T,r,B),t(r,w),o(T,y,B),M(u,T,B),o(T,v,B),o(T,c,B),M($,c,null),t(c,R),o(T,A,B),o(T,x,B),t(x,q),M(_,x,null),t(x,d),o(T,I,B),o(T,b,B),t(b,p),g=!0},p:Ee,i(T){g||(L(u.$$.fragment,T),L($.$$.fragment,T),L(_.$$.fragment,T),g=!0)},o(T){z(u.$$.fragment,T),z($.$$.fragment,T),z(_.$$.fragment,T),g=!1},d(T){T&&e(r),T&&e(y),Q(u,T),T&&e(v),T&&e(c),Q($),T&&e(A),T&&e(x),Q(_),T&&e(I),T&&e(b)}}}function es(j){let r,w,y,u,v,c,$,R,A,x,q,_,d,I,b;return $=new X({props:{language:"yaml",maxHeight:400,scrollToEnd:!1,value:Un}}),I=new Mt({props:{href:"https://github.com/OpenAPITools/openapi-generator-cli",label:"openapi-generator-cli"}}),{c(){r=l("p"),w=i(`Regardless of whether you start with the code or the specification,
      generating one from the other ensures that the two are always aligned and
      streamlines development through centralized updates.`),y=E(),u=l("p"),v=i(`Specification-driven development (i.e., starting with a specification and
      generating the code), offers the advantage of being highly standardized
      and language-agnostic. This makes it easier to get all stakeholders
      involved earlier in the development process.`),c=E(),S($.$$.fragment),R=E(),A=l("p"),x=i(`This simple OpenApi specification, written in YAML, represents a pet store
      API with a single endpoint for retrieving a pet by its ID, which is
      provided in the url. The response is a JSON object with either the pet's
      id and name, or an error message.`),q=E(),_=l("p"),d=i(`With this specification, the API provider can implement it using the
      language of their choosing and generate API documentation. The API
      consumer can generate client code to using tools like `),S(I.$$.fragment)},l(p){r=f(p,"P",{});var g=m(r);w=a(g,`Regardless of whether you start with the code or the specification,
      generating one from the other ensures that the two are always aligned and
      streamlines development through centralized updates.`),g.forEach(e),y=P(p),u=f(p,"P",{});var T=m(u);v=a(T,`Specification-driven development (i.e., starting with a specification and
      generating the code), offers the advantage of being highly standardized
      and language-agnostic. This makes it easier to get all stakeholders
      involved earlier in the development process.`),T.forEach(e),c=P(p),C($.$$.fragment,p),R=P(p),A=f(p,"P",{});var B=m(A);x=a(B,`This simple OpenApi specification, written in YAML, represents a pet store
      API with a single endpoint for retrieving a pet by its ID, which is
      provided in the url. The response is a JSON object with either the pet's
      id and name, or an error message.`),B.forEach(e),q=P(p),_=f(p,"P",{});var k=m(_);d=a(k,`With this specification, the API provider can implement it using the
      language of their choosing and generate API documentation. The API
      consumer can generate client code to using tools like `),C(I.$$.fragment,k),k.forEach(e)},m(p,g){o(p,r,g),t(r,w),o(p,y,g),o(p,u,g),t(u,v),o(p,c,g),M($,p,g),o(p,R,g),o(p,A,g),t(A,x),o(p,q,g),o(p,_,g),t(_,d),M(I,_,null),b=!0},p:Ee,i(p){b||(L($.$$.fragment,p),L(I.$$.fragment,p),b=!0)},o(p){z($.$$.fragment,p),z(I.$$.fragment,p),b=!1},d(p){p&&e(r),p&&e(y),p&&e(u),p&&e(c),Q($,p),p&&e(R),p&&e(A),p&&e(q),p&&e(_),Q(I)}}}function ts(j){let r,w,y,u,v,c,$,R,A,x,q,_;return y=new Mt({props:{href:"https://openapi-ts.pages.dev/",label:"openapi-typescript"}}),c=new X({props:{language:"shell",scrollToEnd:!1,value:"npx openapi-typescript petstore.yaml -o petstore.ts"}}),q=new X({props:{maxHeight:400,scrollToEnd:!1,value:Ln}}),{c(){r=l("p"),w=i("The npm package "),S(y.$$.fragment),u=i(" generates TypeScript types from an OpenAPI specification."),v=E(),S(c.$$.fragment),$=E(),R=l("p"),A=i(`Invoking this command with the sample specification yields a TypeScript
      file with definitions for each request and response.`),x=E(),S(q.$$.fragment)},l(d){r=f(d,"P",{});var I=m(r);w=a(I,"The npm package "),C(y.$$.fragment,I),u=a(I," generates TypeScript types from an OpenAPI specification."),I.forEach(e),v=P(d),C(c.$$.fragment,d),$=P(d),R=f(d,"P",{});var b=m(R);A=a(b,`Invoking this command with the sample specification yields a TypeScript
      file with definitions for each request and response.`),b.forEach(e),x=P(d),C(q.$$.fragment,d)},m(d,I){o(d,r,I),t(r,w),M(y,r,null),t(r,u),o(d,v,I),M(c,d,I),o(d,$,I),o(d,R,I),t(R,A),o(d,x,I),M(q,d,I),_=!0},p:Ee,i(d){_||(L(y.$$.fragment,d),L(c.$$.fragment,d),L(q.$$.fragment,d),_=!0)},o(d){z(y.$$.fragment,d),z(c.$$.fragment,d),z(q.$$.fragment,d),_=!1},d(d){d&&e(r),Q(y),d&&e(v),Q(c,d),d&&e($),d&&e(R),d&&e(x),Q(q,d)}}}function ns(j){let r,w,y,u,v,c,$,R,A,x,q,_,d,I,b,p,g,T,B,k,s,h,W,K,Y,U,Pe,fe,G,_e,se,we,Qe,De,ne,qe,Ve,ce,ee,Ne,re,Fe,Ge,oe,We,Ke,de,me,je,F,Ye,ge,pe,Ue,ue,Je,Xe,Ie,ye,Be,J,ie,Re,Ze,Oe,te,et,$e,tt,nt,be;return u=new X({props:{value:j[1]}}),b=new X({props:{maxHeight:400,scrollToEnd:!1,value:Jn}}),ye=new X({props:{scrollToEnd:!1,value:j[2]}}),{c(){r=l("p"),w=i("Let's take a closer look at the Express route definition."),y=E(),S(u.$$.fragment),v=E(),c=l("p"),$=i("The second argument to "),R=l("code"),A=i("app.get"),x=i(` is an anonymous function with
      the type
      `),q=l("code"),_=i("RequestHandler"),d=i(". Here's the definition provided by Express:"),I=E(),S(b.$$.fragment),p=E(),g=l("p"),T=l("code"),B=i("RequestHandler"),k=i(" has five generic types parameters."),s=E(),h=l("div"),W=l("div"),K=i("P"),Y=E(),U=l("div"),Pe=i("url path parameters"),fe=E(),G=l("div"),_e=i("ResBody"),se=E(),we=l("div"),Qe=i("the response body"),De=E(),ne=l("div"),qe=i("ReqBody"),Ve=E(),ce=l("div"),ee=i("the request body"),Ne=E(),re=l("div"),Fe=i("ReqQuery"),Ge=E(),oe=l("div"),We=i("query string parameters"),Ke=E(),de=l("div"),me=i("LocalData"),je=E(),F=l("div"),Ye=i("local data attached to the response"),ge=E(),pe=l("p"),Ue=i("Our goal is to combine our generated OpenAPI types and "),ue=l("code"),Je=i("RequestHandler"),Xe=i(" to produce something like this:"),Ie=E(),S(ye.$$.fragment),Be=E(),J=l("p"),ie=l("code"),Re=i("ShowPetByIdHandler"),Ze=i(" is a type of "),Oe=l("code"),te=i("RequestHandler"),et=i(`
      that receives a single path parameter `),$e=l("code"),tt=i("petId"),nt=i(` and returns an object
      representing a pet, or an error.`),this.h()},l(O){r=f(O,"P",{});var N=m(r);w=a(N,"Let's take a closer look at the Express route definition."),N.forEach(e),y=P(O),C(u.$$.fragment,O),v=P(O),c=f(O,"P",{});var he=m(c);$=a(he,"The second argument to "),R=f(he,"CODE",{});var Ae=m(R);A=a(Ae,"app.get"),Ae.forEach(e),x=a(he,` is an anonymous function with
      the type
      `),q=f(he,"CODE",{});var st=m(q);_=a(st,"RequestHandler"),st.forEach(e),d=a(he,". Here's the definition provided by Express:"),he.forEach(e),I=P(O),C(b.$$.fragment,O),p=P(O),g=f(O,"P",{});var ae=m(g);T=f(ae,"CODE",{});var ft=m(T);B=a(ft,"RequestHandler"),ft.forEach(e),k=a(ae," has five generic types parameters."),ae.forEach(e),s=P(O),h=f(O,"DIV",{class:!0});var V=m(h);W=f(V,"DIV",{class:!0});var ct=m(W);K=a(ct,"P"),ct.forEach(e),Y=P(V),U=f(V,"DIV",{class:!0});var dt=m(U);Pe=a(dt,"url path parameters"),dt.forEach(e),fe=P(V),G=f(V,"DIV",{class:!0});var rt=m(G);_e=a(rt,"ResBody"),rt.forEach(e),se=P(V),we=f(V,"DIV",{class:!0});var xe=m(we);Qe=a(xe,"the response body"),xe.forEach(e),De=P(V),ne=f(V,"DIV",{class:!0});var He=m(ne);qe=a(He,"ReqBody"),He.forEach(e),Ve=P(V),ce=f(V,"DIV",{class:!0});var mt=m(ce);ee=a(mt,"the request body"),mt.forEach(e),Ne=P(V),re=f(V,"DIV",{class:!0});var ot=m(re);Fe=a(ot,"ReqQuery"),ot.forEach(e),Ge=P(V),oe=f(V,"DIV",{class:!0});var ve=m(oe);We=a(ve,"query string parameters"),ve.forEach(e),Ke=P(V),de=f(V,"DIV",{class:!0});var ut=m(de);me=a(ut,"LocalData"),ut.forEach(e),je=P(V),F=f(V,"DIV",{class:!0});var Se=m(F);Ye=a(Se,"local data attached to the response"),Se.forEach(e),V.forEach(e),ge=P(O),pe=f(O,"P",{});var Ce=m(pe);Ue=a(Ce,"Our goal is to combine our generated OpenAPI types and "),ue=f(Ce,"CODE",{});var yt=m(ue);Je=a(yt,"RequestHandler"),yt.forEach(e),Xe=a(Ce," to produce something like this:"),Ce.forEach(e),Ie=P(O),C(ye.$$.fragment,O),Be=P(O),J=f(O,"P",{});var le=m(J);ie=f(le,"CODE",{});var Te=m(ie);Re=a(Te,"ShowPetByIdHandler"),Te.forEach(e),Ze=a(le," is a type of "),Oe=f(le,"CODE",{});var pt=m(Oe);te=a(pt,"RequestHandler"),pt.forEach(e),et=a(le,`
      that receives a single path parameter `),$e=f(le,"CODE",{});var Z=m($e);tt=a(Z,"petId"),Z.forEach(e),nt=a(le,` and returns an object
      representing a pet, or an error.`),le.forEach(e),this.h()},h(){H(W,"class","svelte-1jzueiw"),H(U,"class","svelte-1jzueiw"),H(G,"class","svelte-1jzueiw"),H(we,"class","svelte-1jzueiw"),H(ne,"class","svelte-1jzueiw"),H(ce,"class","svelte-1jzueiw"),H(re,"class","svelte-1jzueiw"),H(oe,"class","svelte-1jzueiw"),H(de,"class","svelte-1jzueiw"),H(F,"class","svelte-1jzueiw"),H(h,"class","grid-table svelte-1jzueiw")},m(O,N){o(O,r,N),t(r,w),o(O,y,N),M(u,O,N),o(O,v,N),o(O,c,N),t(c,$),t(c,R),t(R,A),t(c,x),t(c,q),t(q,_),t(c,d),o(O,I,N),M(b,O,N),o(O,p,N),o(O,g,N),t(g,T),t(T,B),t(g,k),o(O,s,N),o(O,h,N),t(h,W),t(W,K),t(h,Y),t(h,U),t(U,Pe),t(h,fe),t(h,G),t(G,_e),t(h,se),t(h,we),t(we,Qe),t(h,De),t(h,ne),t(ne,qe),t(h,Ve),t(h,ce),t(ce,ee),t(h,Ne),t(h,re),t(re,Fe),t(h,Ge),t(h,oe),t(oe,We),t(h,Ke),t(h,de),t(de,me),t(h,je),t(h,F),t(F,Ye),o(O,ge,N),o(O,pe,N),t(pe,Ue),t(pe,ue),t(ue,Je),t(pe,Xe),o(O,Ie,N),M(ye,O,N),o(O,Be,N),o(O,J,N),t(J,ie),t(ie,Re),t(J,Ze),t(J,Oe),t(Oe,te),t(J,et),t(J,$e),t($e,tt),t(J,nt),be=!0},p:Ee,i(O){be||(L(u.$$.fragment,O),L(b.$$.fragment,O),L(ye.$$.fragment,O),be=!0)},o(O){z(u.$$.fragment,O),z(b.$$.fragment,O),z(ye.$$.fragment,O),be=!1},d(O){O&&e(r),O&&e(y),Q(u,O),O&&e(v),O&&e(c),O&&e(I),Q(b,O),O&&e(p),O&&e(g),O&&e(s),O&&e(h),O&&e(ge),O&&e(pe),O&&e(Ie),Q(ye,O),O&&e(Be),O&&e(J)}}}function ss(j){let r,w,y,u,v,c,$,R,A,x,q,_,d,I,b,p,g,T,B,k,s,h,W,K,Y,U,Pe,fe,G,_e,se,we,Qe,De,ne,qe,Ve,ce,ee,Ne,re,Fe,Ge,oe,We,Ke,de,me,je,F,Ye,ge,pe,Ue,ue,Je,Xe,Ie,ye,Be,J,ie,Re,Ze,Oe,te,et,$e,tt,nt,be,O,N,he,Ae,st,ae,ft,V,ct,dt,rt,xe,He,mt,ot,ve,ut,Se,Ce,yt,le,Te,pt,Z,Lt,_t,zt,Qt,wt,Vt,Nt,gt,Ft,Gt,Tt,$t,It,Wt,qt,ht,Kt,Rt,it,xt,Me,Yt,Ot,Ut,Jt,kt,at,Dt,lt,bt,Xt,Zt,jt;return $=new X({props:{scrollToEnd:!1,value:j[3]}}),h=new X({props:{scrollToEnd:!1,value:j[4]}}),me=new X({props:{scrollToEnd:!1,value:j[5]}}),Ae=new X({props:{scrollToEnd:!1,value:j[6]}}),Te=new X({props:{scrollToEnd:!1,value:j[7]}}),it=new X({props:{scrollToEnd:!1,value:j[8]}}),at=new X({props:{scrollToEnd:!1,value:At.split(`

`).slice(6,7).join(`

`)}}),{c(){r=l("p"),w=i(`We don't want to manually specify those generic type parameters though,
      they should come from the OpenAPI specification via `),y=l("code"),u=i("openapi-typescript"),v=i(", giving us something like this:"),c=E(),S($.$$.fragment),R=E(),A=l("p"),x=l("b"),q=i("OpenApiRequestHandler"),_=E(),d=l("p"),I=i("Given an "),b=l("code"),p=i("Operation"),g=i(`, we can define the
      `),T=l("code"),B=i("OpenApiRequestHandler"),k=i(" type."),s=E(),S(h.$$.fragment),W=E(),K=l("p"),Y=l("code"),U=i("Locals"),Pe=i(` is the type of the local data attached to the response
      object. Since it's unaffected by the API specification, it simply gets passed
      through.`),fe=E(),G=l("p"),_e=i(`Four intermediate types determine the path parameters, response body,
      request body, and query parameters based on the `),se=l("code"),we=i("Operation"),Qe=i(`.
      Let's look at each of these.`),De=E(),ne=l("p"),qe=l("b"),Ve=i("OpenApiPathParams"),ce=E(),ee=l("p"),Ne=i("Path parameters are defined in "),re=l("code"),Fe=i('Operation["parameters"]["path"]'),Ge=i(". The utility type "),oe=l("code"),We=i("Property"),Ke=i(` is used two to extract the path parameters
      type.`),de=E(),S(me.$$.fragment),je=E(),F=l("p"),Ye=i("So, "),ge=l("code"),pe=i("OpenApiPathParams"),Ue=i(` represents the type of
      `),ue=l("code"),Je=i('Operation["parameters"]["path"]'),Xe=i(` if it exists, or else
      `),Ie=l("code"),ye=i("undefined"),Be=i("."),J=E(),ie=l("p"),Re=l("b"),Ze=i("OpenApiQueryParams"),Oe=E(),te=l("p"),et=i("Next, we'll jump to "),$e=l("code"),tt=i("OpenApiQueryParams"),nt=i(`, since it's nearly the
      same. The only differences are the property path and
      `),be=l("code"),O=i("MapToString"),N=i("."),he=E(),S(Ae.$$.fragment),st=E(),ae=l("p"),ft=i(`It's possible to specify query parameters as numbers or booleans, but
      Express will always parse them as strings. `),V=l("code"),ct=i("MapToString"),dt=i(` is a utility
      type that converts non-string property types to string types. We ignore array
      and object parameters for the sake of simplicity.`),rt=E(),xe=l("p"),He=l("b"),mt=i("OpenApiRequestBody"),ot=E(),ve=l("p"),ut=i("Now let's look at the third intermediate type, "),Se=l("code"),Ce=i("OpenApiRequestBody"),yt=i("."),le=E(),S(Te.$$.fragment),pt=E(),Z=l("p"),Lt=i("Using the "),_t=l("code"),zt=i("Property"),Qt=i(` utility type as before, we extract the
      request body type from `),wt=l("code"),Vt=i('Operation["requestBody"]["content"]'),Nt=i(`.
      This contains a map of MIME types. The
      `),gt=l("code"),Ft=i("Properties"),Gt=i(` utility type provides a union of the body types or
      undefined if there are none.`),Tt=E(),$t=l("p"),It=l("b"),Wt=i("OpenApiResponseBody"),qt=E(),ht=l("p"),Kt=i(`The response body type has one more level of complexity; multiple
      responses with different MIME types.`),Rt=E(),S(it.$$.fragment),xt=E(),Me=l("p"),Yt=i("The response body is defined for each response code and MIME type in "),Ot=l("code"),Ut=i('Operation["responses"][responseCode]["content"][mimeType]'),Jt=i("."),kt=E(),S(at.$$.fragment),Dt=E(),lt=l("p"),bt=l("code"),Xt=i("OpenApiResponseBody"),Zt=i(` extracts and collects response types by response
      code and MIME type.`)},l(n){r=f(n,"P",{});var D=m(r);w=a(D,`We don't want to manually specify those generic type parameters though,
      they should come from the OpenAPI specification via `),y=f(D,"CODE",{});var nn=m(y);u=a(nn,"openapi-typescript"),nn.forEach(e),v=a(D,", giving us something like this:"),D.forEach(e),c=P(n),C($.$$.fragment,n),R=P(n),A=f(n,"P",{});var sn=m(A);x=f(sn,"B",{});var rn=m(x);q=a(rn,"OpenApiRequestHandler"),rn.forEach(e),sn.forEach(e),_=P(n),d=f(n,"P",{});var vt=m(d);I=a(vt,"Given an "),b=f(vt,"CODE",{});var on=m(b);p=a(on,"Operation"),on.forEach(e),g=a(vt,`, we can define the
      `),T=f(vt,"CODE",{});var pn=m(T);B=a(pn,"OpenApiRequestHandler"),pn.forEach(e),k=a(vt," type."),vt.forEach(e),s=P(n),C(h.$$.fragment,n),W=P(n),K=f(n,"P",{});var en=m(K);Y=f(en,"CODE",{});var an=m(Y);U=a(an,"Locals"),an.forEach(e),Pe=a(en,` is the type of the local data attached to the response
      object. Since it's unaffected by the API specification, it simply gets passed
      through.`),en.forEach(e),fe=P(n),G=f(n,"P",{});var Bt=m(G);_e=a(Bt,`Four intermediate types determine the path parameters, response body,
      request body, and query parameters based on the `),se=f(Bt,"CODE",{});var ln=m(se);we=a(ln,"Operation"),ln.forEach(e),Qe=a(Bt,`.
      Let's look at each of these.`),Bt.forEach(e),De=P(n),ne=f(n,"P",{});var fn=m(ne);qe=f(fn,"B",{});var cn=m(qe);Ve=a(cn,"OpenApiPathParams"),cn.forEach(e),fn.forEach(e),ce=P(n),ee=f(n,"P",{});var Et=m(ee);Ne=a(Et,"Path parameters are defined in "),re=f(Et,"CODE",{});var dn=m(re);Fe=a(dn,'Operation["parameters"]["path"]'),dn.forEach(e),Ge=a(Et,". The utility type "),oe=f(Et,"CODE",{});var mn=m(oe);We=a(mn,"Property"),mn.forEach(e),Ke=a(Et,` is used two to extract the path parameters
      type.`),Et.forEach(e),de=P(n),C(me.$$.fragment,n),je=P(n),F=f(n,"P",{});var Le=m(F);Ye=a(Le,"So, "),ge=f(Le,"CODE",{});var un=m(ge);pe=a(un,"OpenApiPathParams"),un.forEach(e),Ue=a(Le,` represents the type of
      `),ue=f(Le,"CODE",{});var yn=m(ue);Je=a(yn,'Operation["parameters"]["path"]'),yn.forEach(e),Xe=a(Le,` if it exists, or else
      `),Ie=f(Le,"CODE",{});var $n=m(Ie);ye=a($n,"undefined"),$n.forEach(e),Be=a(Le,"."),Le.forEach(e),J=P(n),ie=f(n,"P",{});var hn=m(ie);Re=f(hn,"B",{});var vn=m(Re);Ze=a(vn,"OpenApiQueryParams"),vn.forEach(e),hn.forEach(e),Oe=P(n),te=f(n,"P",{});var Pt=m(te);et=a(Pt,"Next, we'll jump to "),$e=f(Pt,"CODE",{});var En=m($e);tt=a(En,"OpenApiQueryParams"),En.forEach(e),nt=a(Pt,`, since it's nearly the
      same. The only differences are the property path and
      `),be=f(Pt,"CODE",{});var Pn=m(be);O=a(Pn,"MapToString"),Pn.forEach(e),N=a(Pt,"."),Pt.forEach(e),he=P(n),C(Ae.$$.fragment,n),st=P(n),ae=f(n,"P",{});var Ht=m(ae);ft=a(Ht,`It's possible to specify query parameters as numbers or booleans, but
      Express will always parse them as strings. `),V=f(Ht,"CODE",{});var _n=m(V);ct=a(_n,"MapToString"),_n.forEach(e),dt=a(Ht,` is a utility
      type that converts non-string property types to string types. We ignore array
      and object parameters for the sake of simplicity.`),Ht.forEach(e),rt=P(n),xe=f(n,"P",{});var wn=m(xe);He=f(wn,"B",{});var gn=m(He);mt=a(gn,"OpenApiRequestBody"),gn.forEach(e),wn.forEach(e),ot=P(n),ve=f(n,"P",{});var St=m(ve);ut=a(St,"Now let's look at the third intermediate type, "),Se=f(St,"CODE",{});var In=m(Se);Ce=a(In,"OpenApiRequestBody"),In.forEach(e),yt=a(St,"."),St.forEach(e),le=P(n),C(Te.$$.fragment,n),pt=P(n),Z=f(n,"P",{});var ze=m(Z);Lt=a(ze,"Using the "),_t=f(ze,"CODE",{});var On=m(_t);zt=a(On,"Property"),On.forEach(e),Qt=a(ze,` utility type as before, we extract the
      request body type from `),wt=f(ze,"CODE",{});var bn=m(wt);Vt=a(bn,'Operation["requestBody"]["content"]'),bn.forEach(e),Nt=a(ze,`.
      This contains a map of MIME types. The
      `),gt=f(ze,"CODE",{});var An=m(gt);Ft=a(An,"Properties"),An.forEach(e),Gt=a(ze,` utility type provides a union of the body types or
      undefined if there are none.`),ze.forEach(e),Tt=P(n),$t=f(n,"P",{});var Tn=m($t);It=f(Tn,"B",{});var qn=m(It);Wt=a(qn,"OpenApiResponseBody"),qn.forEach(e),Tn.forEach(e),qt=P(n),ht=f(n,"P",{});var Rn=m(ht);Kt=a(Rn,`The response body type has one more level of complexity; multiple
      responses with different MIME types.`),Rn.forEach(e),Rt=P(n),C(it.$$.fragment,n),xt=P(n),Me=f(n,"P",{});var Ct=m(Me);Yt=a(Ct,"The response body is defined for each response code and MIME type in "),Ot=f(Ct,"CODE",{});var xn=m(Ot);Ut=a(xn,'Operation["responses"][responseCode]["content"][mimeType]'),xn.forEach(e),Jt=a(Ct,"."),Ct.forEach(e),kt=P(n),C(at.$$.fragment,n),Dt=P(n),lt=f(n,"P",{});var tn=m(lt);bt=f(tn,"CODE",{});var kn=m(bt);Xt=a(kn,"OpenApiResponseBody"),kn.forEach(e),Zt=a(tn,` extracts and collects response types by response
      code and MIME type.`),tn.forEach(e)},m(n,D){o(n,r,D),t(r,w),t(r,y),t(y,u),t(r,v),o(n,c,D),M($,n,D),o(n,R,D),o(n,A,D),t(A,x),t(x,q),o(n,_,D),o(n,d,D),t(d,I),t(d,b),t(b,p),t(d,g),t(d,T),t(T,B),t(d,k),o(n,s,D),M(h,n,D),o(n,W,D),o(n,K,D),t(K,Y),t(Y,U),t(K,Pe),o(n,fe,D),o(n,G,D),t(G,_e),t(G,se),t(se,we),t(G,Qe),o(n,De,D),o(n,ne,D),t(ne,qe),t(qe,Ve),o(n,ce,D),o(n,ee,D),t(ee,Ne),t(ee,re),t(re,Fe),t(ee,Ge),t(ee,oe),t(oe,We),t(ee,Ke),o(n,de,D),M(me,n,D),o(n,je,D),o(n,F,D),t(F,Ye),t(F,ge),t(ge,pe),t(F,Ue),t(F,ue),t(ue,Je),t(F,Xe),t(F,Ie),t(Ie,ye),t(F,Be),o(n,J,D),o(n,ie,D),t(ie,Re),t(Re,Ze),o(n,Oe,D),o(n,te,D),t(te,et),t(te,$e),t($e,tt),t(te,nt),t(te,be),t(be,O),t(te,N),o(n,he,D),M(Ae,n,D),o(n,st,D),o(n,ae,D),t(ae,ft),t(ae,V),t(V,ct),t(ae,dt),o(n,rt,D),o(n,xe,D),t(xe,He),t(He,mt),o(n,ot,D),o(n,ve,D),t(ve,ut),t(ve,Se),t(Se,Ce),t(ve,yt),o(n,le,D),M(Te,n,D),o(n,pt,D),o(n,Z,D),t(Z,Lt),t(Z,_t),t(_t,zt),t(Z,Qt),t(Z,wt),t(wt,Vt),t(Z,Nt),t(Z,gt),t(gt,Ft),t(Z,Gt),o(n,Tt,D),o(n,$t,D),t($t,It),t(It,Wt),o(n,qt,D),o(n,ht,D),t(ht,Kt),o(n,Rt,D),M(it,n,D),o(n,xt,D),o(n,Me,D),t(Me,Yt),t(Me,Ot),t(Ot,Ut),t(Me,Jt),o(n,kt,D),M(at,n,D),o(n,Dt,D),o(n,lt,D),t(lt,bt),t(bt,Xt),t(lt,Zt),jt=!0},p:Ee,i(n){jt||(L($.$$.fragment,n),L(h.$$.fragment,n),L(me.$$.fragment,n),L(Ae.$$.fragment,n),L(Te.$$.fragment,n),L(it.$$.fragment,n),L(at.$$.fragment,n),jt=!0)},o(n){z($.$$.fragment,n),z(h.$$.fragment,n),z(me.$$.fragment,n),z(Ae.$$.fragment,n),z(Te.$$.fragment,n),z(it.$$.fragment,n),z(at.$$.fragment,n),jt=!1},d(n){n&&e(r),n&&e(c),Q($,n),n&&e(R),n&&e(A),n&&e(_),n&&e(d),n&&e(s),Q(h,n),n&&e(W),n&&e(K),n&&e(fe),n&&e(G),n&&e(De),n&&e(ne),n&&e(ce),n&&e(ee),n&&e(de),Q(me,n),n&&e(je),n&&e(F),n&&e(J),n&&e(ie),n&&e(Oe),n&&e(te),n&&e(he),Q(Ae,n),n&&e(st),n&&e(ae),n&&e(rt),n&&e(xe),n&&e(ot),n&&e(ve),n&&e(le),Q(Te,n),n&&e(pt),n&&e(Z),n&&e(Tt),n&&e($t),n&&e(qt),n&&e(ht),n&&e(Rt),Q(it,n),n&&e(xt),n&&e(Me),n&&e(kt),Q(at,n),n&&e(Dt),n&&e(lt)}}}function rs(j){let r,w,y,u,v,c,$,R,A,x,q,_,d,I,b,p,g,T,B;return u=new X({props:{scrollToEnd:!1,value:Yn}}),{c(){r=l("p"),w=i(`If you didn't follow all that it's ok! Here's the important part:
      typechecking against the OpenAPI specification.`),y=E(),S(u.$$.fragment),v=E(),c=l("p"),$=i(`Notice that apart from extracting the request handler and specifying it's
      type, the responses have also changed. That's because the types didn't
      match the API specification and the type checker caught it.`),R=E(),A=l("div"),x=l("div"),q=l("img"),d=E(),I=l("p"),b=i("Here's the modified "),p=l("code"),g=i("showPetByIdHandler"),T=i(" type:"),this.h()},l(k){r=f(k,"P",{});var s=m(r);w=a(s,`If you didn't follow all that it's ok! Here's the important part:
      typechecking against the OpenAPI specification.`),s.forEach(e),y=P(k),C(u.$$.fragment,k),v=P(k),c=f(k,"P",{});var h=m(c);$=a(h,`Notice that apart from extracting the request handler and specifying it's
      type, the responses have also changed. That's because the types didn't
      match the API specification and the type checker caught it.`),h.forEach(e),R=P(k),A=f(k,"DIV",{class:!0});var W=m(A);x=f(W,"DIV",{class:!0});var K=m(x);q=f(K,"IMG",{src:!0,alt:!0}),K.forEach(e),W.forEach(e),d=P(k),I=f(k,"P",{});var Y=m(I);b=a(Y,"Here's the modified "),p=f(Y,"CODE",{});var U=m(p);g=a(U,"showPetByIdHandler"),U.forEach(e),T=a(Y," type:"),Y.forEach(e),this.h()},h(){Vn(q.src,_="/request-handler-error.png")||H(q,"src",_),H(q,"alt","Type error"),H(x,"class","card-body"),H(A,"class","card margin-bottom-large")},m(k,s){o(k,r,s),t(r,w),o(k,y,s),M(u,k,s),o(k,v,s),o(k,c,s),t(c,$),o(k,R,s),o(k,A,s),t(A,x),t(x,q),o(k,d,s),o(k,I,s),t(I,b),t(I,p),t(p,g),t(I,T),B=!0},p:Ee,i(k){B||(L(u.$$.fragment,k),B=!0)},o(k){z(u.$$.fragment,k),B=!1},d(k){k&&e(r),k&&e(y),Q(u,k),k&&e(v),k&&e(c),k&&e(R),k&&e(A),k&&e(d),k&&e(I)}}}function os(j){let r,w,y,u,v,c,$,R,A,x,q;return x=new X({props:{scrollToEnd:!1,value:Xn}}),{c(){r=l("p"),w=i("Finally, we can use the utility type "),y=l("code"),u=i("Equal"),v=i(` to verify that the
      `),c=l("code"),$=i("RequestHandler"),R=i(" was derived correctly."),A=E(),S(x.$$.fragment)},l(_){r=f(_,"P",{});var d=m(r);w=a(d,"Finally, we can use the utility type "),y=f(d,"CODE",{});var I=m(y);u=a(I,"Equal"),I.forEach(e),v=a(d,` to verify that the
      `),c=f(d,"CODE",{});var b=m(c);$=a(b,"RequestHandler"),b.forEach(e),R=a(d," was derived correctly."),d.forEach(e),A=P(_),C(x.$$.fragment,_)},m(_,d){o(_,r,d),t(r,w),t(r,y),t(y,u),t(r,v),t(r,c),t(c,$),t(r,R),o(_,A,d),M(x,_,d),q=!0},p:Ee,i(_){q||(L(x.$$.fragment,_),q=!0)},o(_){z(x.$$.fragment,_),q=!1},d(_){_&&e(r),_&&e(A),Q(x,_)}}}function ps(j){let r,w,y,u,v,c,$,R,A,x,q;return{c(){r=l("p"),w=i(`We've seen how to generate TypeScript types from an OpenAPI specification
      and use them to type-check an Express API. This approach ensures that the
      API documentation and code remain in sync as the API evolves.`),y=E(),u=l("p"),v=i("By adding a script to a projects "),c=l("code"),$=i("package.json"),R=i(`, it's easy to
      rerun `),A=l("code"),x=i("openapi-typescript"),q=i(`
      whenever the specification changes.`)},l(_){r=f(_,"P",{});var d=m(r);w=a(d,`We've seen how to generate TypeScript types from an OpenAPI specification
      and use them to type-check an Express API. This approach ensures that the
      API documentation and code remain in sync as the API evolves.`),d.forEach(e),y=P(_),u=f(_,"P",{});var I=m(u);v=a(I,"By adding a script to a projects "),c=f(I,"CODE",{});var b=m(c);$=a(b,"package.json"),b.forEach(e),R=a(I,`, it's easy to
      rerun `),A=f(I,"CODE",{});var p=m(A);x=a(p,"openapi-typescript"),p.forEach(e),q=a(I,`
      whenever the specification changes.`),I.forEach(e)},m(_,d){o(_,r,d),t(r,w),o(_,y,d),o(_,u,d),t(u,v),t(u,c),t(c,$),t(u,R),t(u,A),t(A,x),t(u,q)},p:Ee,d(_){_&&e(r),_&&e(y),_&&e(u)}}}function is(j){let r,w,y,u,v;return{c(){r=l("p"),w=i(`In terms of the original goal of generating API documentation, this
      approach was quite successful. I started by taking a guess at the
      specification, or generating one by using online tools and observing
      requests and responses. The type-checker then guided me to the correct the
      code or the specification until the two were in agreeance.`),y=E(),u=l("p"),v=i(`One improvement that would be nice is a way to ensure the response code
      corresponds with the body type.`),this.h()},l(c){r=f(c,"P",{});var $=m(r);w=a($,`In terms of the original goal of generating API documentation, this
      approach was quite successful. I started by taking a guess at the
      specification, or generating one by using online tools and observing
      requests and responses. The type-checker then guided me to the correct the
      code or the specification until the two were in agreeance.`),$.forEach(e),y=P(c),u=f(c,"P",{class:!0});var R=m(u);v=a(R,`One improvement that would be nice is a way to ensure the response code
      corresponds with the body type.`),R.forEach(e),this.h()},h(){H(u,"class","margin-large-bottom")},m(c,$){o(c,r,$),t(r,w),o(c,y,$),o(c,u,$),t(u,v)},p:Ee,d(c){c&&e(r),c&&e(y),c&&e(u)}}}function as(j){let r,w,y,u,v,c,$,R,A,x,q,_,d,I,b,p,g,T,B,k;return r=new ke({props:{title:"",$$slots:{default:[Zn]},$$scope:{ctx:j}}}),y=new ke({props:{title:"Specification-driven development",$$slots:{default:[es]},$$scope:{ctx:j}}}),v=new ke({props:{title:"Generating TypeScript types",$$slots:{default:[ts]},$$scope:{ctx:j}}}),$=new ke({props:{title:"Express Types",$$slots:{default:[ns]},$$scope:{ctx:j}}}),A=new ke({props:{title:"OpenAPI types in Express",$$slots:{default:[ss]},$$scope:{ctx:j}}}),q=new ke({props:{title:"Type-checking the API",$$slots:{default:[rs]},$$scope:{ctx:j}}}),d=new ke({props:{title:"Testing",$$slots:{default:[os]},$$scope:{ctx:j}}}),b=new ke({props:{title:"Moving Forward",$$slots:{default:[ps]},$$scope:{ctx:j}}}),g=new ke({props:{title:"Conclusion",$$slots:{default:[is]},$$scope:{ctx:j}}}),B=new Nn({props:{resources:[{href:"https://www.openapis.org/",label:"OpenAPI Initiative",type:"docs"},{href:"https://openapi-ts.pages.dev/",label:"OpenAPI TypeScript",type:"package"},{href:"https://openapi-generator-cli",label:"OpenAPI Generator CLI",type:"package"},{href:"https://medium.com/@angela.tt/the-easiest-and-quickest-way-to-generate-an-openapi-spec-for-an-existing-website-12b5ad6e36db",label:"The Easiest and Quickest Way to Generate an OpenAPI Spec for an Existing Website",type:"article"}]}}),{c(){S(r.$$.fragment),w=E(),S(y.$$.fragment),u=E(),S(v.$$.fragment),c=E(),S($.$$.fragment),R=E(),S(A.$$.fragment),x=E(),S(q.$$.fragment),_=E(),S(d.$$.fragment),I=E(),S(b.$$.fragment),p=E(),S(g.$$.fragment),T=E(),S(B.$$.fragment)},l(s){C(r.$$.fragment,s),w=P(s),C(y.$$.fragment,s),u=P(s),C(v.$$.fragment,s),c=P(s),C($.$$.fragment,s),R=P(s),C(A.$$.fragment,s),x=P(s),C(q.$$.fragment,s),_=P(s),C(d.$$.fragment,s),I=P(s),C(b.$$.fragment,s),p=P(s),C(g.$$.fragment,s),T=P(s),C(B.$$.fragment,s)},m(s,h){M(r,s,h),o(s,w,h),M(y,s,h),o(s,u,h),M(v,s,h),o(s,c,h),M($,s,h),o(s,R,h),M(A,s,h),o(s,x,h),M(q,s,h),o(s,_,h),M(d,s,h),o(s,I,h),M(b,s,h),o(s,p,h),M(g,s,h),o(s,T,h),M(B,s,h),k=!0},p(s,h){const W={};h&512&&(W.$$scope={dirty:h,ctx:s}),r.$set(W);const K={};h&512&&(K.$$scope={dirty:h,ctx:s}),y.$set(K);const Y={};h&512&&(Y.$$scope={dirty:h,ctx:s}),v.$set(Y);const U={};h&512&&(U.$$scope={dirty:h,ctx:s}),$.$set(U);const Pe={};h&512&&(Pe.$$scope={dirty:h,ctx:s}),A.$set(Pe);const fe={};h&512&&(fe.$$scope={dirty:h,ctx:s}),q.$set(fe);const G={};h&512&&(G.$$scope={dirty:h,ctx:s}),d.$set(G);const _e={};h&512&&(_e.$$scope={dirty:h,ctx:s}),b.$set(_e);const se={};h&512&&(se.$$scope={dirty:h,ctx:s}),g.$set(se)},i(s){k||(L(r.$$.fragment,s),L(y.$$.fragment,s),L(v.$$.fragment,s),L($.$$.fragment,s),L(A.$$.fragment,s),L(q.$$.fragment,s),L(d.$$.fragment,s),L(b.$$.fragment,s),L(g.$$.fragment,s),L(B.$$.fragment,s),k=!0)},o(s){z(r.$$.fragment,s),z(y.$$.fragment,s),z(v.$$.fragment,s),z($.$$.fragment,s),z(A.$$.fragment,s),z(q.$$.fragment,s),z(d.$$.fragment,s),z(b.$$.fragment,s),z(g.$$.fragment,s),z(B.$$.fragment,s),k=!1},d(s){Q(r,s),s&&e(w),Q(y,s),s&&e(u),Q(v,s),s&&e(c),Q($,s),s&&e(R),Q(A,s),s&&e(x),Q(q,s),s&&e(_),Q(d,s),s&&e(I),Q(b,s),s&&e(p),Q(g,s),s&&e(T),Q(B,s)}}}function ls(j){let r;return{c(){r=i("Making an Express API adhere to an OpenAPI specification")},l(w){r=a(w,"Making an Express API adhere to an OpenAPI specification")},m(w,y){o(w,r,y)},d(w){w&&e(r)}}}function fs(j){let r,w,y,u;return r=new Kn({props:{title:Bn,description:cs,slug:ds}}),y=new Fn({props:{title:Bn,date:j[0],$$slots:{tldr:[ls],default:[as]},$$scope:{ctx:j}}}),{c(){S(r.$$.fragment),w=E(),S(y.$$.fragment)},l(v){const c=Qn("svelte-19co01u",document.head);C(r.$$.fragment,c),c.forEach(e),w=P(v),C(y.$$.fragment,v)},m(v,c){M(r,document.head,null),o(v,w,c),M(y,v,c),u=!0},p(v,[c]){const $={};c&512&&($.$$scope={dirty:c,ctx:v}),y.$set($)},i(v){u||(L(r.$$.fragment,v),L(y.$$.fragment,v),u=!0)},o(v){z(r.$$.fragment,v),z(y.$$.fragment,v),u=!1},d(v){Q(r),v&&e(w),Q(y,v)}}}const Bn="Type-safe Express APIs",cs="Specification-driven development with OpenAPI and Express",ds="express-openapi";function ms(j){const r=new Date("May 27, 2024"),w=Mn.split(`

`).slice(3,4).join(`

`),y=jn.split(`

`).slice(0,2).join(`

`),u=jn.split(`

`).slice(2,4).join(`

`),v=At.split(`

`).slice(0,2).join(`

`),c=At.split(`

`).slice(2,4).join(`

`),$=At.split(`

`).slice(7).join(`

`),R=At.split(`

`).slice(4,6).join(`

`),A=Ln.split(`
`).slice(50,64).join(`
`);return[r,w,y,u,v,c,$,R,A]}class vs extends Hn{constructor(r){super(),Sn(this,r,ms,fs,Cn,{})}}export{vs as default};
