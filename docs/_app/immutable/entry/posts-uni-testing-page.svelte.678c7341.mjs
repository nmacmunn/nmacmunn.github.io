import{S as Ie,i as Pe,s as Te,C as Ne,k as h,a as T,q as w,l as g,m as k,h as t,c as A,r as v,n as X,b as p,D as $,F as Ge,G as ze,H as Je,u as Ye,g as D,d as U,y as M,K as Xe,z as F,A as j,B as L,I as Y,O as Qe,p as Oe}from"../chunks/index.4711a160.mjs";import{S as ie,R as Ke,A as ke}from"../chunks/resources.cfbab304.mjs";import{A as Ze}from"../chunks/article.06c607fb.mjs";import{S as fe}from"../chunks/snippet.e1d427ae.mjs";function et(P){let e,f,i,s,d,o,a,m,c;const l=P[2].default,r=Ne(l,P,P[1],null);return{c(){e=h("div"),f=h("p"),i=h("i"),r&&r.c(),s=T(),d=h("p"),o=h("small"),a=w("- "),m=w(P[0]),this.h()},l(n){e=g(n,"DIV",{class:!0});var u=k(e);f=g(u,"P",{class:!0});var _=k(f);i=g(_,"I",{});var S=k(i);r&&r.l(S),S.forEach(t),_.forEach(t),s=A(u),d=g(u,"P",{class:!0});var C=k(d);o=g(C,"SMALL",{});var I=k(o);a=v(I,"- "),m=v(I,P[0]),I.forEach(t),C.forEach(t),u.forEach(t),this.h()},h(){X(f,"class","quote svelte-1wtwg41"),X(d,"class","padding-left"),X(e,"class","padding-left padding-right")},m(n,u){p(n,e,u),$(e,f),$(f,i),r&&r.m(i,null),$(e,s),$(e,d),$(d,o),$(o,a),$(o,m),c=!0},p(n,[u]){r&&r.p&&(!c||u&2)&&Ge(r,l,n,n[1],c?Je(l,n[1],u,null):ze(n[1]),null),(!c||u&1)&&Ye(m,n[0])},i(n){c||(D(r,n),c=!0)},o(n){U(r,n),c=!1},d(n){n&&t(e),r&&r.d(n)}}}function tt(P,e,f){let{$$slots:i={},$$scope:s}=e,{author:d}=e;return P.$$set=o=>{"author"in o&&f(0,d=o.author),"$$scope"in o&&f(1,s=o.$$scope)},[d,s,i]}class Ae extends Ie{constructor(e){super(),Pe(this,e,tt,et,Te,{author:0})}}function st(P){let e,f,i,s;const d=P[2].default,o=Ne(d,P,P[1],null);return{c(){e=h("h4"),f=w(P[0]),i=T(),o&&o.c()},l(a){e=g(a,"H4",{});var m=k(e);f=v(m,P[0]),m.forEach(t),i=A(a),o&&o.l(a)},m(a,m){p(a,e,m),$(e,f),p(a,i,m),o&&o.m(a,m),s=!0},p(a,[m]){(!s||m&1)&&Ye(f,a[0]),o&&o.p&&(!s||m&2)&&Ge(o,d,a,a[1],s?Je(d,a[1],m,null):ze(a[1]),null)},i(a){s||(D(o,a),s=!0)},o(a){U(o,a),s=!1},d(a){a&&t(e),a&&t(i),o&&o.d(a)}}}function ot(P,e,f){let{$$slots:i={},$$scope:s}=e,{title:d}=e;return P.$$set=o=>{"title"in o&&f(0,d=o.title),"$$scope"in o&&f(1,s=o.$$scope)},[d,s,i]}class J extends Ie{constructor(e){super(),Pe(this,e,ot,st,Te,{title:0})}}function nt(P){let e;return{c(){e=w(`Does this belong here? Am I doing the same thing elsewhere? Is this
      consistent with the rest of the code?`)},l(f){e=v(f,`Does this belong here? Am I doing the same thing elsewhere? Is this
      consistent with the rest of the code?`)},m(f,i){p(f,e,i)},d(f){f&&t(e)}}}function it(P){let e,f,i,s,d,o,a,m,c,l,r;return a=new Ae({props:{author:"Me, while testing",$$slots:{default:[nt]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`I'm a big advocate of unit testing and typically aim for 100% code
      coverage on anything that's going to see real use.`),i=T(),s=h("p"),d=w(`Aside from improving stability, reliability, and maintainability, the
      test-writing process forces me to ask some hard-hitting questions.`),o=T(),M(a.$$.fragment),m=T(),c=h("p"),l=w(`It's kind of like a code pre-review. It improves the codebase and my
      understanding of it.`)},l(n){e=g(n,"P",{});var u=k(e);f=v(u,`I'm a big advocate of unit testing and typically aim for 100% code
      coverage on anything that's going to see real use.`),u.forEach(t),i=A(n),s=g(n,"P",{});var _=k(s);d=v(_,`Aside from improving stability, reliability, and maintainability, the
      test-writing process forces me to ask some hard-hitting questions.`),_.forEach(t),o=A(n),F(a.$$.fragment,n),m=A(n),c=g(n,"P",{});var S=k(c);l=v(S,`It's kind of like a code pre-review. It improves the codebase and my
      understanding of it.`),S.forEach(t)},m(n,u){p(n,e,u),$(e,f),p(n,i,u),p(n,s,u),$(s,d),p(n,o,u),j(a,n,u),p(n,m,u),p(n,c,u),$(c,l),r=!0},p(n,u){const _={};u&512&&(_.$$scope={dirty:u,ctx:n}),a.$set(_)},i(n){r||(D(a.$$.fragment,n),r=!0)},o(n){U(a.$$.fragment,n),r=!1},d(n){n&&t(e),n&&t(i),n&&t(s),n&&t(o),L(a,n),n&&t(m),n&&t(c)}}}function at(P){let e,f,i,s,d,o,a,m,c,l;return s=new fe({props:{value:P[2],language:"typescript"}}),c=new fe({props:{value:P[3],language:"typescript"}}),{c(){e=h("p"),f=w(`The lines of code for unit tests typically outnumber those belonging to
        the module under test. Here is an example from the Jest documentation.`),i=T(),M(s.$$.fragment),d=T(),o=h("p"),a=w(`That's about as simple as it gets. The corresponding test is about the
        same size yet far from comprehensive.`),m=T(),M(c.$$.fragment)},l(r){e=g(r,"P",{});var n=k(e);f=v(n,`The lines of code for unit tests typically outnumber those belonging to
        the module under test. Here is an example from the Jest documentation.`),n.forEach(t),i=A(r),F(s.$$.fragment,r),d=A(r),o=g(r,"P",{});var u=k(o);a=v(u,`That's about as simple as it gets. The corresponding test is about the
        same size yet far from comprehensive.`),u.forEach(t),m=A(r),F(c.$$.fragment,r)},m(r,n){p(r,e,n),$(e,f),p(r,i,n),j(s,r,n),p(r,d,n),p(r,o,n),$(o,a),p(r,m,n),j(c,r,n),l=!0},p:Y,i(r){l||(D(s.$$.fragment,r),D(c.$$.fragment,r),l=!0)},o(r){U(s.$$.fragment,r),U(c.$$.fragment,r),l=!1},d(r){r&&t(e),r&&t(i),L(s,r),r&&t(d),r&&t(o),r&&t(m),L(c,r)}}}function rt(P){let e;return{c(){e=w(`You may also find yourself testing implementation details just so you
        can make sure you get that one line of code that's hard to reproduce in
        a test environment. You really want to avoid testing implementation
        details because it doesn't give you very much confidence that your
        application is working and it slows you down when refactoring.`)},l(f){e=v(f,`You may also find yourself testing implementation details just so you
        can make sure you get that one line of code that's hard to reproduce in
        a test environment. You really want to avoid testing implementation
        details because it doesn't give you very much confidence that your
        application is working and it slows you down when refactoring.`)},m(f,i){p(f,e,i)},d(f){f&&t(e)}}}function lt(P){let e,f,i,s,d,o,a,m,c,l,r;return a=new Ae({props:{author:"Kent C Dodds",$$slots:{default:[rt]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`Unit tests tend to get obliterated in refactoring. That makes sense
        because when you refactor, you're changing the units. In theory, many
        test cases should make it into the new tests. However in practice, it's
        often easier to rewrite them.`),i=T(),s=h("p"),d=w("Another problem arises specifically when testing with code coverage."),o=T(),M(a.$$.fragment),m=T(),c=h("p"),l=w(`I once read that software is either in one of two states: constant
        refactoring or dying. Neither bodes particularly well for unit tests.`)},l(n){e=g(n,"P",{});var u=k(e);f=v(u,`Unit tests tend to get obliterated in refactoring. That makes sense
        because when you refactor, you're changing the units. In theory, many
        test cases should make it into the new tests. However in practice, it's
        often easier to rewrite them.`),u.forEach(t),i=A(n),s=g(n,"P",{});var _=k(s);d=v(_,"Another problem arises specifically when testing with code coverage."),_.forEach(t),o=A(n),F(a.$$.fragment,n),m=A(n),c=g(n,"P",{});var S=k(c);l=v(S,`I once read that software is either in one of two states: constant
        refactoring or dying. Neither bodes particularly well for unit tests.`),S.forEach(t)},m(n,u){p(n,e,u),$(e,f),p(n,i,u),p(n,s,u),$(s,d),p(n,o,u),j(a,n,u),p(n,m,u),p(n,c,u),$(c,l),r=!0},p(n,u){const _={};u&512&&(_.$$scope={dirty:u,ctx:n}),a.$set(_)},i(n){r||(D(a.$$.fragment,n),r=!0)},o(n){U(a.$$.fragment,n),r=!1},d(n){n&&t(e),n&&t(i),n&&t(s),n&&t(o),L(a,n),n&&t(m),n&&t(c)}}}function ft(P){let e,f;return{c(){e=h("p"),f=w(`Writing code that is readily testable takes more time and effort than
        just getting something working. When you're prototyping, designing for
        test may not make sense and returning to make your code testable later
        can be expensive.`)},l(i){e=g(i,"P",{});var s=k(e);f=v(s,`Writing code that is readily testable takes more time and effort than
        just getting something working. When you're prototyping, designing for
        test may not make sense and returning to make your code testable later
        can be expensive.`),s.forEach(t)},m(i,s){p(i,e,s),$(e,f)},p:Y,d(i){i&&t(e)}}}function ut(P){let e,f;return{c(){e=h("p"),f=w(`We tend to treat test code as second-class and don't hold it to the same
        quality standard as production code. For example, I normally aim to keep
        my functions short and files under 200 lines whenever possible yet
        flagrantly ignore these guidelines when testing. Why? Test code is still
        code.`)},l(i){e=g(i,"P",{});var s=k(e);f=v(s,`We tend to treat test code as second-class and don't hold it to the same
        quality standard as production code. For example, I normally aim to keep
        my functions short and files under 200 lines whenever possible yet
        flagrantly ignore these guidelines when testing. Why? Test code is still
        code.`),s.forEach(t)},m(i,s){p(i,e,s),$(e,f)},p:Y,d(i){i&&t(e)}}}function pt(P){let e,f;return{c(){e=h("p"),f=w(`I could live with all of the above if no bugs ever made it to
        production. Many are caught, some aren't, and some seem embarrassingly
        obvious.`)},l(i){e=g(i,"P",{});var s=k(e);f=v(s,`I could live with all of the above if no bugs ever made it to
        production. Many are caught, some aren't, and some seem embarrassingly
        obvious.`),s.forEach(t)},m(i,s){p(i,e,s),$(e,f)},p:Y,d(i){i&&t(e)}}}function ct(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S,C,I,E,W;return l=new J({props:{title:"Volume",$$slots:{default:[at]},$$scope:{ctx:P}}}),n=new J({props:{title:"Refactoring",$$slots:{default:[lt]},$$scope:{ctx:P}}}),_=new J({props:{title:"Designing for Test",$$slots:{default:[ft]},$$scope:{ctx:P}}}),C=new J({props:{title:"Quality",$$slots:{default:[ut]},$$scope:{ctx:P}}}),E=new J({props:{title:"Bugs",$$slots:{default:[pt]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`You're probably thinking,
      `),i=h("i"),s=w('"Great! Sounds like this software quality thing is just about licked."'),d=w(`
      Unfortunately, such is not the case.`),o=T(),a=h("p"),m=w(`After writing many thousands of unit tests and reaching 100% code coverage
      across many codebases, the same problems keep cropping up.`),c=T(),M(l.$$.fragment),r=T(),M(n.$$.fragment),u=T(),M(_.$$.fragment),S=T(),M(C.$$.fragment),I=T(),M(E.$$.fragment)},l(b){e=g(b,"P",{});var x=k(e);f=v(x,`You're probably thinking,
      `),i=g(x,"I",{});var O=k(i);s=v(O,'"Great! Sounds like this software quality thing is just about licked."'),O.forEach(t),d=v(x,`
      Unfortunately, such is not the case.`),x.forEach(t),o=A(b),a=g(b,"P",{});var V=k(a);m=v(V,`After writing many thousands of unit tests and reaching 100% code coverage
      across many codebases, the same problems keep cropping up.`),V.forEach(t),c=A(b),F(l.$$.fragment,b),r=A(b),F(n.$$.fragment,b),u=A(b),F(_.$$.fragment,b),S=A(b),F(C.$$.fragment,b),I=A(b),F(E.$$.fragment,b)},m(b,x){p(b,e,x),$(e,f),$(e,i),$(i,s),$(e,d),p(b,o,x),p(b,a,x),$(a,m),p(b,c,x),j(l,b,x),p(b,r,x),j(n,b,x),p(b,u,x),j(_,b,x),p(b,S,x),j(C,b,x),p(b,I,x),j(E,b,x),W=!0},p(b,x){const O={};x&512&&(O.$$scope={dirty:x,ctx:b}),l.$set(O);const V={};x&512&&(V.$$scope={dirty:x,ctx:b}),n.$set(V);const Q={};x&512&&(Q.$$scope={dirty:x,ctx:b}),_.$set(Q);const y={};x&512&&(y.$$scope={dirty:x,ctx:b}),C.$set(y);const R={};x&512&&(R.$$scope={dirty:x,ctx:b}),E.$set(R)},i(b){W||(D(l.$$.fragment,b),D(n.$$.fragment,b),D(_.$$.fragment,b),D(C.$$.fragment,b),D(E.$$.fragment,b),W=!0)},o(b){U(l.$$.fragment,b),U(n.$$.fragment,b),U(_.$$.fragment,b),U(C.$$.fragment,b),U(E.$$.fragment,b),W=!1},d(b){b&&t(e),b&&t(o),b&&t(a),b&&t(c),L(l,b),b&&t(r),L(n,b),b&&t(u),L(_,b),b&&t(S),L(C,b),b&&t(I),L(E,b)}}}function mt(P){let e,f,i,s,d,o,a,m;return{c(){e=h("p"),f=w("Catches bugs and improves understanding "),i=h("b"),s=w("initially"),d=w(` when written
        and `),o=h("b"),a=w("continuously"),m=w(" and as changes are made.")},l(c){e=g(c,"P",{});var l=k(e);f=v(l,"Catches bugs and improves understanding "),i=g(l,"B",{});var r=k(i);s=v(r,"initially"),r.forEach(t),d=v(l,` when written
        and `),o=g(l,"B",{});var n=k(o);a=v(n,"continuously"),n.forEach(t),m=v(l," and as changes are made."),l.forEach(t)},m(c,l){p(c,e,l),$(e,f),$(e,i),$(i,s),$(e,d),$(e,o),$(o,a),$(e,m)},p:Y,d(c){c&&t(e)}}}function $t(P){let e,f,i,s,d,o,a,m,c,l,r;return{c(){e=h("p"),f=w("Quick "),i=h("b"),s=w("to run"),d=w(`, the faster the better. If you're tempted to do
        something else while your tests run, you start to pay context switching
        costs.`),o=T(),a=h("p"),m=w("Quick "),c=h("b"),l=w("to write"),r=w(`. We prefer to spend our time changing the world
        with production code after all.`)},l(n){e=g(n,"P",{});var u=k(e);f=v(u,"Quick "),i=g(u,"B",{});var _=k(i);s=v(_,"to run"),_.forEach(t),d=v(u,`, the faster the better. If you're tempted to do
        something else while your tests run, you start to pay context switching
        costs.`),u.forEach(t),o=A(n),a=g(n,"P",{});var S=k(a);m=v(S,"Quick "),c=g(S,"B",{});var C=k(c);l=v(C,"to write"),C.forEach(t),r=v(S,`. We prefer to spend our time changing the world
        with production code after all.`),S.forEach(t)},m(n,u){p(n,e,u),$(e,f),$(e,i),$(i,s),$(e,d),p(n,o,u),p(n,a,u),$(a,m),$(a,c),$(c,l),$(a,r)},p:Y,d(n){n&&t(e),n&&t(o),n&&t(a)}}}function dt(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_;return{c(){e=h("p"),f=h("b"),i=w("Short"),s=w(`. Software bugs are strongly correlated with lines of code
        and there's really no reason to expect test code to be different.`),d=T(),o=h("p"),a=h("b"),m=w("High quality"),c=w(`. Tests should be held to the same quality standard
        as the rest of our code. We want to be able to tell at a glance what's
        being tested and how.`),l=T(),r=h("p"),n=h("b"),u=w("Decoupled"),_=w(`. Tests not depending on code being written in a
        particular way are more resilient to changes and lets you focus on
        expressing intent.`)},l(S){e=g(S,"P",{});var C=k(e);f=g(C,"B",{});var I=k(f);i=v(I,"Short"),I.forEach(t),s=v(C,`. Software bugs are strongly correlated with lines of code
        and there's really no reason to expect test code to be different.`),C.forEach(t),d=A(S),o=g(S,"P",{});var E=k(o);a=g(E,"B",{});var W=k(a);m=v(W,"High quality"),W.forEach(t),c=v(E,`. Tests should be held to the same quality standard
        as the rest of our code. We want to be able to tell at a glance what's
        being tested and how.`),E.forEach(t),l=A(S),r=g(S,"P",{});var b=k(r);n=g(b,"B",{});var x=k(n);u=v(x,"Decoupled"),x.forEach(t),_=v(b,`. Tests not depending on code being written in a
        particular way are more resilient to changes and lets you focus on
        expressing intent.`),b.forEach(t)},m(S,C){p(S,e,C),$(e,f),$(f,i),$(e,s),p(S,d,C),p(S,o,C),$(o,a),$(a,m),$(o,c),p(S,l,C),p(S,r,C),$(r,n),$(n,u),$(r,_)},p:Y,d(S){S&&t(e),S&&t(d),S&&t(o),S&&t(l),S&&t(r)}}}function ht(P){let e,f,i,s,d,o,a,m,c;return{c(){e=h("p"),f=h("b"),i=w("Reliable"),s=w(`. No false positives or negatives. It's hard to think of
        anything more frustrating for a coder than debugging an intermittent
        test failure that doesn't affect users.`),d=T(),o=h("p"),a=h("b"),m=w("Targeted"),c=w(`. Introducing a bug causes a single test to fail, clearly
        indicating what the problem is.`)},l(l){e=g(l,"P",{});var r=k(e);f=g(r,"B",{});var n=k(f);i=v(n,"Reliable"),n.forEach(t),s=v(r,`. No false positives or negatives. It's hard to think of
        anything more frustrating for a coder than debugging an intermittent
        test failure that doesn't affect users.`),r.forEach(t),d=A(l),o=g(l,"P",{});var u=k(o);a=g(u,"B",{});var _=k(a);m=v(_,"Targeted"),_.forEach(t),c=v(u,`. Introducing a bug causes a single test to fail, clearly
        indicating what the problem is.`),u.forEach(t)},m(l,r){p(l,e,r),$(e,f),$(f,i),$(e,s),p(l,d,r),p(l,o,r),$(o,a),$(a,m),$(o,c)},p:Y,d(l){l&&t(e),l&&t(d),l&&t(o)}}}function gt(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S,C,I;return m=new fe({props:{value:P[5],language:"typescript"}}),l=new J({props:{title:"Effective",$$slots:{default:[mt]},$$scope:{ctx:P}}}),n=new J({props:{title:"Fast",$$slots:{default:[$t]},$$scope:{ctx:P}}}),_=new J({props:{title:"Maintainable",$$slots:{default:[dt]},$$scope:{ctx:P}}}),C=new J({props:{title:"Low Frustration",$$slots:{default:[ht]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`These issues combined seem like a high price to pay for a partial
      solution. After accepting that no test suite could prove my program's
      correctness, I started thinking about a more pragmatic approach to testing
      and some of the qualities of an ideal test suite.`),i=T(),s=h("p"),d=h("small"),o=w("Optimist's Rendition of Ideal Test Suite:"),a=T(),M(m.$$.fragment),c=T(),M(l.$$.fragment),r=T(),M(n.$$.fragment),u=T(),M(_.$$.fragment),S=T(),M(C.$$.fragment),this.h()},l(E){e=g(E,"P",{});var W=k(e);f=v(W,`These issues combined seem like a high price to pay for a partial
      solution. After accepting that no test suite could prove my program's
      correctness, I started thinking about a more pragmatic approach to testing
      and some of the qualities of an ideal test suite.`),W.forEach(t),i=A(E),s=g(E,"P",{class:!0});var b=k(s);d=g(b,"SMALL",{});var x=k(d);o=v(x,"Optimist's Rendition of Ideal Test Suite:"),x.forEach(t),b.forEach(t),a=A(E),F(m.$$.fragment,E),c=A(E),F(l.$$.fragment,E),r=A(E),F(n.$$.fragment,E),u=A(E),F(_.$$.fragment,E),S=A(E),F(C.$$.fragment,E),this.h()},h(){X(s,"class","margin-left")},m(E,W){p(E,e,W),$(e,f),p(E,i,W),p(E,s,W),$(s,d),$(d,o),p(E,a,W),j(m,E,W),p(E,c,W),j(l,E,W),p(E,r,W),j(n,E,W),p(E,u,W),j(_,E,W),p(E,S,W),j(C,E,W),I=!0},p(E,W){const b={};W&512&&(b.$$scope={dirty:W,ctx:E}),l.$set(b);const x={};W&512&&(x.$$scope={dirty:W,ctx:E}),n.$set(x);const O={};W&512&&(O.$$scope={dirty:W,ctx:E}),_.$set(O);const V={};W&512&&(V.$$scope={dirty:W,ctx:E}),C.$set(V)},i(E){I||(D(m.$$.fragment,E),D(l.$$.fragment,E),D(n.$$.fragment,E),D(_.$$.fragment,E),D(C.$$.fragment,E),I=!0)},o(E){U(m.$$.fragment,E),U(l.$$.fragment,E),U(n.$$.fragment,E),U(_.$$.fragment,E),U(C.$$.fragment,E),I=!1},d(E){E&&t(e),E&&t(i),E&&t(s),E&&t(a),L(m,E),E&&t(c),L(l,E),E&&t(r),L(n,E),E&&t(u),L(_,E),E&&t(S),L(C,E)}}}function wt(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S,C,I,E,W,b,x,O,V,Q,y,R,te;return{c(){e=h("p"),f=w(`So the brute force unit testing approach isn't enough. What about
      end-to-end testing?`),i=T(),s=h("p"),d=w(`Anyone who's done any UI automation knows that special brand of
      frustration known as the flaky test. In 2014, I was consulting on a
      MeteorJS project that had hundreds of E2E tests using Selenium and
      PhantomJS. Here's the `),o=h("b"),a=w("git log"),m=w(" as I remember it."),c=T(),l=h("div"),r=h("pre"),n=w(P[1]),u=T(),_=h("p"),S=w(`Reliability is a major concern with E2E testing; investigating false
      positives can get costly.`),C=T(),I=h("p"),E=w(`Difficulty isolating failures is another concern. When a test does fail,
      how easy is it to identify the reason?`),W=T(),b=h("p"),x=w(`A final concern is speed. Bringing up browsers and loading apps inevitably
      takes time.`),O=T(),V=h("p"),Q=w(`Fortunately, native browser support for UI automation and modern tools
      like Playwright (Trace Viewer FTW 👏) have come a long way toward
      improving reliability and identifying failures.`),y=T(),R=h("p"),te=w("So what can we do about speed?"),this.h()},l(H){e=g(H,"P",{});var z=k(e);f=v(z,`So the brute force unit testing approach isn't enough. What about
      end-to-end testing?`),z.forEach(t),i=A(H),s=g(H,"P",{});var K=k(s);d=v(K,`Anyone who's done any UI automation knows that special brand of
      frustration known as the flaky test. In 2014, I was consulting on a
      MeteorJS project that had hundreds of E2E tests using Selenium and
      PhantomJS. Here's the `),o=g(K,"B",{});var oe=k(o);a=v(oe,"git log"),oe.forEach(t),m=v(K," as I remember it."),K.forEach(t),c=A(H),l=g(H,"DIV",{class:!0});var B=k(l);r=g(B,"PRE",{});var N=k(r);n=v(N,P[1]),N.forEach(t),B.forEach(t),u=A(H),_=g(H,"P",{});var Z=k(_);S=v(Z,`Reliability is a major concern with E2E testing; investigating false
      positives can get costly.`),Z.forEach(t),C=A(H),I=g(H,"P",{});var ee=k(I);E=v(ee,`Difficulty isolating failures is another concern. When a test does fail,
      how easy is it to identify the reason?`),ee.forEach(t),W=A(H),b=g(H,"P",{});var ne=k(b);x=v(ne,`A final concern is speed. Bringing up browsers and loading apps inevitably
      takes time.`),ne.forEach(t),O=A(H),V=g(H,"P",{});var se=k(V);Q=v(se,`Fortunately, native browser support for UI automation and modern tools
      like Playwright (Trace Viewer FTW 👏) have come a long way toward
      improving reliability and identifying failures.`),se.forEach(t),y=A(H),R=g(H,"P",{});var ae=k(R);te=v(ae,"So what can we do about speed?"),ae.forEach(t),this.h()},h(){X(l,"class","padding-left padding-right")},m(H,z){p(H,e,z),$(e,f),p(H,i,z),p(H,s,z),$(s,d),$(s,o),$(o,a),$(s,m),p(H,c,z),p(H,l,z),$(l,r),$(r,n),p(H,u,z),p(H,_,z),$(_,S),p(H,C,z),p(H,I,z),$(I,E),p(H,W,z),p(H,b,z),$(b,x),p(H,O,z),p(H,V,z),$(V,Q),p(H,y,z),p(H,R,z),$(R,te)},p:Y,d(H){H&&t(e),H&&t(i),H&&t(s),H&&t(c),H&&t(l),H&&t(u),H&&t(_),H&&t(C),H&&t(I),H&&t(W),H&&t(b),H&&t(O),H&&t(V),H&&t(y),H&&t(R)}}}function vt(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S,C,I,E,W,b,x,O,V,Q,y,R,te,H,z,K,oe,B,N,Z,ee,ne,se,ae,re,le,ue,$e,pe,ye,de,ce,Se="< 100% Covered?",_e,he,me,Ee,ge;return _=new fe({props:{value:P[7]}}),{c(){e=h("p"),f=w(`Creating the test was relatively painless with Playwright, a bit of
        hacking, and the following process.`),i=T(),s=h("div"),d=h("img"),a=T(),m=h("h5"),c=w("Run Test"),l=T(),r=h("p"),n=w(`Run the test with a custom test runner (see below). Initially just
        navigate to the home page.`),u=T(),M(_.$$.fragment),S=T(),C=h("h5"),I=w("Start Inspector"),E=T(),W=h("p"),b=w("Start the Playwright Inspector (Code Generator) by appending "),x=h("code"),O=w("page.pause()"),V=w(" to the end of the test. The test runner shown below does so automatically."),Q=T(),y=h("h5"),R=w("Exercise Uncovered"),te=T(),H=h("p"),z=w(`The hardest part of the process is viewing code coverage. The easiest
        way is to write the coverage output to disk and use the `),K=h("code"),oe=w("c8"),B=w(` package
        to generate HTML reports.`),N=T(),Z=h("p"),ee=w(`Look for uncovered code that can be easily exercised from the current
        state. Start recording with the inspector and perform the necessary
        actions manually.`),ne=T(),se=h("h5"),ae=w("Add to Test"),re=T(),le=h("p"),ue=w(`Copy the recorded steps into the test. Give complex locators clear
        variable names and look for reuse opportunities.`),$e=T(),pe=h("p"),ye=w("Run again ensuring the new steps work and cover the targeted lines."),de=T(),ce=h("h5"),_e=w(Se),he=T(),me=h("p"),Ee=w("Repeat the cycle until everything is covered."),this.h()},l(q){e=g(q,"P",{});var G=k(e);f=v(G,`Creating the test was relatively painless with Playwright, a bit of
        hacking, and the following process.`),G.forEach(t),i=A(q),s=g(q,"DIV",{});var qe=k(s);d=g(qe,"IMG",{src:!0,alt:!0,class:!0}),qe.forEach(t),a=A(q),m=g(q,"H5",{});var Ce=k(m);c=v(Ce,"Run Test"),Ce.forEach(t),l=A(q),r=g(q,"P",{});var xe=k(r);n=v(xe,`Run the test with a custom test runner (see below). Initially just
        navigate to the home page.`),xe.forEach(t),u=A(q),F(_.$$.fragment,q),S=A(q),C=g(q,"H5",{});var We=k(C);I=v(We,"Start Inspector"),We.forEach(t),E=A(q),W=g(q,"P",{});var we=k(W);b=v(we,"Start the Playwright Inspector (Code Generator) by appending "),x=g(we,"CODE",{});var He=k(x);O=v(He,"page.pause()"),He.forEach(t),V=v(we," to the end of the test. The test runner shown below does so automatically."),we.forEach(t),Q=A(q),y=g(q,"H5",{});var Re=k(y);R=v(Re,"Exercise Uncovered"),Re.forEach(t),te=A(q),H=g(q,"P",{});var ve=k(H);z=v(ve,`The hardest part of the process is viewing code coverage. The easiest
        way is to write the coverage output to disk and use the `),K=g(ve,"CODE",{});var Be=k(K);oe=v(Be,"c8"),Be.forEach(t),B=v(ve,` package
        to generate HTML reports.`),ve.forEach(t),N=A(q),Z=g(q,"P",{});var De=k(Z);ee=v(De,`Look for uncovered code that can be easily exercised from the current
        state. Start recording with the inspector and perform the necessary
        actions manually.`),De.forEach(t),ne=A(q),se=g(q,"H5",{});var Ue=k(se);ae=v(Ue,"Add to Test"),Ue.forEach(t),re=A(q),le=g(q,"P",{});var Me=k(le);ue=v(Me,`Copy the recorded steps into the test. Give complex locators clear
        variable names and look for reuse opportunities.`),Me.forEach(t),$e=A(q),pe=g(q,"P",{});var Fe=k(pe);ye=v(Fe,"Run again ensuring the new steps work and cover the targeted lines."),Fe.forEach(t),de=A(q),ce=g(q,"H5",{});var je=k(ce);_e=v(je,Se),je.forEach(t),he=A(q),me=g(q,"P",{});var Le=k(me);Ee=v(Le,"Repeat the cycle until everything is covered."),Le.forEach(t),this.h()},h(){Qe(d.src,o="../playwright-process.svg")||X(d,"src",o),X(d,"alt","Process cycle diagram"),X(d,"class","svelte-1yye97l"),Oe(s,"display","flex"),Oe(s,"justify-content","center")},m(q,G){p(q,e,G),$(e,f),p(q,i,G),p(q,s,G),$(s,d),p(q,a,G),p(q,m,G),$(m,c),p(q,l,G),p(q,r,G),$(r,n),p(q,u,G),j(_,q,G),p(q,S,G),p(q,C,G),$(C,I),p(q,E,G),p(q,W,G),$(W,b),$(W,x),$(x,O),$(W,V),p(q,Q,G),p(q,y,G),$(y,R),p(q,te,G),p(q,H,G),$(H,z),$(H,K),$(K,oe),$(H,B),p(q,N,G),p(q,Z,G),$(Z,ee),p(q,ne,G),p(q,se,G),$(se,ae),p(q,re,G),p(q,le,G),$(le,ue),p(q,$e,G),p(q,pe,G),$(pe,ye),p(q,de,G),p(q,ce,G),$(ce,_e),p(q,he,G),p(q,me,G),$(me,Ee),ge=!0},p:Y,i(q){ge||(D(_.$$.fragment,q),ge=!0)},o(q){U(_.$$.fragment,q),ge=!1},d(q){q&&t(e),q&&t(i),q&&t(s),q&&t(a),q&&t(m),q&&t(l),q&&t(r),q&&t(u),L(_,q),q&&t(S),q&&t(C),q&&t(E),q&&t(W),q&&t(Q),q&&t(y),q&&t(te),q&&t(H),q&&t(N),q&&t(Z),q&&t(ne),q&&t(se),q&&t(re),q&&t(le),q&&t($e),q&&t(pe),q&&t(de),q&&t(ce),q&&t(he),q&&t(me)}}}function bt(P){let e,f,i,s,d,o,a,m;return s=new fe({props:{language:"typescript",value:P[6]}}),{c(){e=h("p"),f=w(`Here's a simplified version of the custom test runner used in the above
        process.`),i=T(),M(s.$$.fragment),d=T(),o=h("p"),a=w(`The hacking part has to do with aggregating the test coverage and
        dealing with sourcemaps. It's omitted as it could easily fill another
        post.`)},l(c){e=g(c,"P",{});var l=k(e);f=v(l,`Here's a simplified version of the custom test runner used in the above
        process.`),l.forEach(t),i=A(c),F(s.$$.fragment,c),d=A(c),o=g(c,"P",{});var r=k(o);a=v(r,`The hacking part has to do with aggregating the test coverage and
        dealing with sourcemaps. It's omitted as it could easily fill another
        post.`),r.forEach(t)},m(c,l){p(c,e,l),$(e,f),p(c,i,l),j(s,c,l),p(c,d,l),p(c,o,l),$(o,a),m=!0},p:Y,i(c){m||(D(s.$$.fragment,c),m=!0)},o(c){U(s.$$.fragment,c),m=!1},d(c){c&&t(e),c&&t(i),L(s,c),c&&t(d),c&&t(o)}}}function yt(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S,C,I,E,W,b,x,O,V,Q,y,R,te,H,z,K,oe;return o=new ke({props:{href:"https://playwright.dev/docs/best-practices",label:"Playwright Best Practices"}}),W=new ke({props:{href:"https://venue.tube",label:"VenueTube"}}),H=new J({props:{title:"The Process",$$slots:{default:[vt]},$$scope:{ctx:P}}}),K=new J({props:{title:"Test Runner",$$slots:{default:[bt]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`A thing we can do is reduce the number of tests. All the way down. Like,
      one test.`),i=T(),s=h("p"),d=w("From "),M(o.$$.fragment),a=w(":"),m=T(),c=h("div"),l=h("p"),r=h("strong"),n=w("Write fewer tests but longer tests"),u=T(),_=h("p"),S=w(`When it comes to end to end testing having long tests is not a bad
        thing. It's ok to have multiple actions and assertions in your test so
        you can test complete App flows. You should avoid separating your
        assertions into individual test blocks as it doesn't really bring much
        value and just slows down the running of your tests.`),C=T(),I=h("p"),E=w(`Here's a test exercising all of the front-end code for
      `),M(W.$$.fragment),b=w(" showing real-time code coverage."),x=T(),O=h("div"),V=h("video"),Q=h("source"),R=h("track"),te=T(),M(H.$$.fragment),z=T(),M(K.$$.fragment),this.h()},l(B){e=g(B,"P",{});var N=k(e);f=v(N,`A thing we can do is reduce the number of tests. All the way down. Like,
      one test.`),N.forEach(t),i=A(B),s=g(B,"P",{});var Z=k(s);d=v(Z,"From "),F(o.$$.fragment,Z),a=v(Z,":"),Z.forEach(t),m=A(B),c=g(B,"DIV",{class:!0});var ee=k(c);l=g(ee,"P",{});var ne=k(l);r=g(ne,"STRONG",{});var se=k(r);n=v(se,"Write fewer tests but longer tests"),se.forEach(t),ne.forEach(t),u=A(ee),_=g(ee,"P",{});var ae=k(_);S=v(ae,`When it comes to end to end testing having long tests is not a bad
        thing. It's ok to have multiple actions and assertions in your test so
        you can test complete App flows. You should avoid separating your
        assertions into individual test blocks as it doesn't really bring much
        value and just slows down the running of your tests.`),ae.forEach(t),ee.forEach(t),C=A(B),I=g(B,"P",{});var re=k(I);E=v(re,`Here's a test exercising all of the front-end code for
      `),F(W.$$.fragment,re),b=v(re," showing real-time code coverage."),re.forEach(t),x=A(B),O=g(B,"DIV",{class:!0});var le=k(O);V=g(le,"VIDEO",{class:!0});var ue=k(V);Q=g(ue,"SOURCE",{src:!0,type:!0}),R=g(ue,"TRACK",{kind:!0}),ue.forEach(t),le.forEach(t),te=A(B),F(H.$$.fragment,B),z=A(B),F(K.$$.fragment,B),this.h()},h(){X(c,"class","padding-left padding-right padding-bottom"),Qe(Q.src,y="../unitest.webm")||X(Q,"src",y),X(Q,"type","video/webm"),X(R,"kind","captions"),V.controls=!0,X(V,"class","svelte-1yye97l"),X(O,"class","card margin-bottom-large")},m(B,N){p(B,e,N),$(e,f),p(B,i,N),p(B,s,N),$(s,d),j(o,s,null),$(s,a),p(B,m,N),p(B,c,N),$(c,l),$(l,r),$(r,n),$(c,u),$(c,_),$(_,S),p(B,C,N),p(B,I,N),$(I,E),j(W,I,null),$(I,b),p(B,x,N),p(B,O,N),$(O,V),$(V,Q),$(V,R),p(B,te,N),j(H,B,N),p(B,z,N),j(K,B,N),oe=!0},p(B,N){const Z={};N&512&&(Z.$$scope={dirty:N,ctx:B}),H.$set(Z);const ee={};N&512&&(ee.$$scope={dirty:N,ctx:B}),K.$set(ee)},i(B){oe||(D(o.$$.fragment,B),D(W.$$.fragment,B),D(H.$$.fragment,B),D(K.$$.fragment,B),oe=!0)},o(B){U(o.$$.fragment,B),U(W.$$.fragment,B),U(H.$$.fragment,B),U(K.$$.fragment,B),oe=!1},d(B){B&&t(e),B&&t(i),B&&t(s),L(o),B&&t(m),B&&t(c),B&&t(C),B&&t(I),L(W),B&&t(x),B&&t(O),B&&t(te),L(H,B),B&&t(z),L(K,B)}}}function _t(P){let e,f,i,s,d,o,a,m,c,l,r;return{c(){e=h("p"),f=w(`Because VenueTube uses passwordless authentication, signing in took a
        bit of work. I used the `),i=h("code"),s=w("nodemailer"),d=w(` package to create an
        ethereal.email account that's API accessible. Then I used the
        `),o=h("code"),a=w("imapflow"),m=w(`
        package to get the signin email and `),c=h("code"),l=w("mailparser"),r=w(` to extract the
        link.`)},l(n){e=g(n,"P",{});var u=k(e);f=v(u,`Because VenueTube uses passwordless authentication, signing in took a
        bit of work. I used the `),i=g(u,"CODE",{});var _=k(i);s=v(_,"nodemailer"),_.forEach(t),d=v(u,` package to create an
        ethereal.email account that's API accessible. Then I used the
        `),o=g(u,"CODE",{});var S=k(o);a=v(S,"imapflow"),S.forEach(t),m=v(u,`
        package to get the signin email and `),c=g(u,"CODE",{});var C=k(c);l=v(C,"mailparser"),C.forEach(t),r=v(u,` to extract the
        link.`),u.forEach(t)},m(n,u){p(n,e,u),$(e,f),$(e,i),$(i,s),$(e,d),$(e,o),$(o,a),$(e,m),$(e,c),$(c,l),$(e,r)},p:Y,d(n){n&&t(e)}}}function Et(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S;return{c(){e=h("p"),f=w(`Firebase Authentication is one of the external APIs that the application
        sends requests to. Playwright provides a way to intercept requests and
        provide your own response. I didn't because:`),i=T(),s=h("ol"),d=h("li"),o=w("I don't intend to run the test in CI (yet)"),a=T(),m=h("li"),c=w("Hitting the real thing is low consequence"),l=T(),r=h("li"),n=w("It's more realistic this way"),u=T(),_=h("p"),S=w("I did have to simulate a webhook to complete one workflow.")},l(C){e=g(C,"P",{});var I=k(e);f=v(I,`Firebase Authentication is one of the external APIs that the application
        sends requests to. Playwright provides a way to intercept requests and
        provide your own response. I didn't because:`),I.forEach(t),i=A(C),s=g(C,"OL",{});var E=k(s);d=g(E,"LI",{});var W=k(d);o=v(W,"I don't intend to run the test in CI (yet)"),W.forEach(t),a=A(E),m=g(E,"LI",{});var b=k(m);c=v(b,"Hitting the real thing is low consequence"),b.forEach(t),l=A(E),r=g(E,"LI",{});var x=k(r);n=v(x,"It's more realistic this way"),x.forEach(t),E.forEach(t),u=A(C),_=g(C,"P",{});var O=k(_);S=v(O,"I did have to simulate a webhook to complete one workflow."),O.forEach(t)},m(C,I){p(C,e,I),$(e,f),p(C,i,I),p(C,s,I),$(s,d),$(d,o),$(s,a),$(s,m),$(m,c),$(s,l),$(s,r),$(r,n),p(C,u,I),p(C,_,I),$(_,S)},p:Y,d(C){C&&t(e),C&&t(i),C&&t(s),C&&t(u),C&&t(_)}}}function kt(P){let e,f;return{c(){e=h("p"),f=w(`Exercising error handlers took some understanding of failure modes and a
        bit of tampering with reality. For example, to test the Sentry
        integration, I injected a script into the page to throw an exception
        (obviously none of my actual code would 😉).`)},l(i){e=g(i,"P",{});var s=k(e);f=v(s,`Exercising error handlers took some understanding of failure modes and a
        bit of tampering with reality. For example, to test the Sentry
        integration, I injected a script into the page to throw an exception
        (obviously none of my actual code would 😉).`),s.forEach(t)},m(i,s){p(i,e,s),$(e,f)},p:Y,d(i){i&&t(e)}}}function It(P){let e,f,i,s,d,o,a,m,c;return s=new J({props:{title:"Authentication",$$slots:{default:[_t]},$$scope:{ctx:P}}}),o=new J({props:{title:"External APIs",$$slots:{default:[Et]},$$scope:{ctx:P}}}),m=new J({props:{title:"Error Handling",$$slots:{default:[kt]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`These should be no surprise to experienced E2E testers but if you spend
      most of your time on unit tests, you'll have some new challenges to
      consider.`),i=T(),M(s.$$.fragment),d=T(),M(o.$$.fragment),a=T(),M(m.$$.fragment)},l(l){e=g(l,"P",{});var r=k(e);f=v(r,`These should be no surprise to experienced E2E testers but if you spend
      most of your time on unit tests, you'll have some new challenges to
      consider.`),r.forEach(t),i=A(l),F(s.$$.fragment,l),d=A(l),F(o.$$.fragment,l),a=A(l),F(m.$$.fragment,l)},m(l,r){p(l,e,r),$(e,f),p(l,i,r),j(s,l,r),p(l,d,r),j(o,l,r),p(l,a,r),j(m,l,r),c=!0},p(l,r){const n={};r&512&&(n.$$scope={dirty:r,ctx:l}),s.$set(n);const u={};r&512&&(u.$$scope={dirty:r,ctx:l}),o.$set(u);const _={};r&512&&(_.$$scope={dirty:r,ctx:l}),m.$set(_)},i(l){c||(D(s.$$.fragment,l),D(o.$$.fragment,l),D(m.$$.fragment,l),c=!0)},o(l){U(s.$$.fragment,l),U(o.$$.fragment,l),U(m.$$.fragment,l),c=!1},d(l){l&&t(e),l&&t(i),L(s,l),l&&t(d),L(o,l),l&&t(a),L(m,l)}}}function Pt(P){let e,f,i,s,d;return{c(){e=h("p"),f=w(`I caught a number of bugs, found dead code, and identified some really
        bad UX in the course of writing the test which I wouldn't have with unit
        testing. That said, there are almost certainly still bugs that unit
        tests would catch.`),i=T(),s=h("p"),d=w(`Whether the test catches regressions as features are added remains to be
        seen.`)},l(o){e=g(o,"P",{});var a=k(e);f=v(a,`I caught a number of bugs, found dead code, and identified some really
        bad UX in the course of writing the test which I wouldn't have with unit
        testing. That said, there are almost certainly still bugs that unit
        tests would catch.`),a.forEach(t),i=A(o),s=g(o,"P",{});var m=k(s);d=v(m,`Whether the test catches regressions as features are added remains to be
        seen.`),m.forEach(t)},m(o,a){p(o,e,a),$(e,f),p(o,i,a),p(o,s,a),$(s,d)},p:Y,d(o){o&&t(e),o&&t(i),o&&t(s)}}}function Tt(P){let e,f,i,s,d;return{c(){e=h("p"),f=w(`It takes about 90s which is close to the upper limit of what I'm likely
        to tolerate. We'll discuss opportunities to improve in a bit.`),i=T(),s=h("p"),d=w(`Correcting for one-time costs (Playwright learning curve and writing the
        test runner), it took about a day to actually write the test.`)},l(o){e=g(o,"P",{});var a=k(e);f=v(a,`It takes about 90s which is close to the upper limit of what I'm likely
        to tolerate. We'll discuss opportunities to improve in a bit.`),a.forEach(t),i=A(o),s=g(o,"P",{});var m=k(s);d=v(m,`Correcting for one-time costs (Playwright learning curve and writing the
        test runner), it took about a day to actually write the test.`),m.forEach(t)},m(o,a){p(o,e,a),$(e,f),p(o,i,a),p(o,s,a),$(s,d)},p:Y,d(o){o&&t(e),o&&t(i),o&&t(s)}}}function At(P){let e,f,i,s,d,o,a,m,c,l,r;return a=new fe({props:{value:`const clearButton = searchContainer.locator('[uk-icon="close"]');`}}),{c(){e=h("p"),f=w("It's short. Around 250 lines."),i=T(),s=h("p"),d=w(`Because the test was so short, I wasn't too concerned about quality. I
        did assign non-obvious element selectors to clearly named variables and
        group common sequences into reusable functions.`),o=T(),M(a.$$.fragment),m=T(),c=h("p"),l=w(`I didn't change any application code for the sake of the test although
        there were a few places where a different structure would be mutually
        beneficial. This indicates that the test should be resilient to
        application refactoring.`)},l(n){e=g(n,"P",{});var u=k(e);f=v(u,"It's short. Around 250 lines."),u.forEach(t),i=A(n),s=g(n,"P",{});var _=k(s);d=v(_,`Because the test was so short, I wasn't too concerned about quality. I
        did assign non-obvious element selectors to clearly named variables and
        group common sequences into reusable functions.`),_.forEach(t),o=A(n),F(a.$$.fragment,n),m=A(n),c=g(n,"P",{});var S=k(c);l=v(S,`I didn't change any application code for the sake of the test although
        there were a few places where a different structure would be mutually
        beneficial. This indicates that the test should be resilient to
        application refactoring.`),S.forEach(t)},m(n,u){p(n,e,u),$(e,f),p(n,i,u),p(n,s,u),$(s,d),p(n,o,u),j(a,n,u),p(n,m,u),p(n,c,u),$(c,l),r=!0},p:Y,i(n){r||(D(a.$$.fragment,n),r=!0)},o(n){U(a.$$.fragment,n),r=!1},d(n){n&&t(e),n&&t(i),n&&t(s),n&&t(o),L(a,n),n&&t(m),n&&t(c)}}}function St(P){let e,f,i,s,d;return{c(){e=h("p"),f=w(`There is definitely still some flakiness but Playwright's Trace Viewer
        really simplifies finding the cause (typically poor selector choice).`),i=T(),s=h("p"),d=w(`If a Playwright command fails, it prints a debugging message and I
        explicitly log each step. However, if the failure is a real problem, it
        could take some digging through the app code to find.`)},l(o){e=g(o,"P",{});var a=k(e);f=v(a,`There is definitely still some flakiness but Playwright's Trace Viewer
        really simplifies finding the cause (typically poor selector choice).`),a.forEach(t),i=A(o),s=g(o,"P",{});var m=k(s);d=v(m,`If a Playwright command fails, it prints a debugging message and I
        explicitly log each step. However, if the failure is a real problem, it
        could take some digging through the app code to find.`),m.forEach(t)},m(o,a){p(o,e,a),$(e,f),p(o,i,a),p(o,s,a),$(s,d)},p:Y,d(o){o&&t(e),o&&t(i),o&&t(s)}}}function qt(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S,C;return s=new fe({props:{language:"typescript",value:P[8]}}),c=new J({props:{title:"Effectiveness",$$slots:{default:[Pt]},$$scope:{ctx:P}}}),r=new J({props:{title:"Speed",$$slots:{default:[Tt]},$$scope:{ctx:P}}}),u=new J({props:{title:"Maintainability",$$slots:{default:[At]},$$scope:{ctx:P}}}),S=new J({props:{title:"Frustration Factor",$$slots:{default:[St]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w("Here's what the test looked like early on in the writing process."),i=T(),M(s.$$.fragment),d=T(),o=h("p"),a=w("So how does this solution stack up against our ideal test suite?"),m=T(),M(c.$$.fragment),l=T(),M(r.$$.fragment),n=T(),M(u.$$.fragment),_=T(),M(S.$$.fragment)},l(I){e=g(I,"P",{});var E=k(e);f=v(E,"Here's what the test looked like early on in the writing process."),E.forEach(t),i=A(I),F(s.$$.fragment,I),d=A(I),o=g(I,"P",{});var W=k(o);a=v(W,"So how does this solution stack up against our ideal test suite?"),W.forEach(t),m=A(I),F(c.$$.fragment,I),l=A(I),F(r.$$.fragment,I),n=A(I),F(u.$$.fragment,I),_=A(I),F(S.$$.fragment,I)},m(I,E){p(I,e,E),$(e,f),p(I,i,E),j(s,I,E),p(I,d,E),p(I,o,E),$(o,a),p(I,m,E),j(c,I,E),p(I,l,E),j(r,I,E),p(I,n,E),j(u,I,E),p(I,_,E),j(S,I,E),C=!0},p(I,E){const W={};E&512&&(W.$$scope={dirty:E,ctx:I}),c.$set(W);const b={};E&512&&(b.$$scope={dirty:E,ctx:I}),r.$set(b);const x={};E&512&&(x.$$scope={dirty:E,ctx:I}),u.$set(x);const O={};E&512&&(O.$$scope={dirty:E,ctx:I}),S.$set(O)},i(I){C||(D(s.$$.fragment,I),D(c.$$.fragment,I),D(r.$$.fragment,I),D(u.$$.fragment,I),D(S.$$.fragment,I),C=!0)},o(I){U(s.$$.fragment,I),U(c.$$.fragment,I),U(r.$$.fragment,I),U(u.$$.fragment,I),U(S.$$.fragment,I),C=!1},d(I){I&&t(e),I&&t(i),L(s,I),I&&t(d),I&&t(o),I&&t(m),L(c,I),I&&t(l),L(r,I),I&&t(n),L(u,I),I&&t(_),L(S,I)}}}function Ct(P){let e,f,i,s,d,o,a,m,c,l,r;return i=new ke({props:{href:"https://pipedream.com",label:"pipedream"}}),{c(){e=h("p"),f=w("VenueTube started as a "),M(i.$$.fragment),s=w(` script and evolved from there based on user feedback. There was never
        a formal plan or even workflow documentation.`),d=T(),o=h("p"),a=w(`Finding and eliminating uncovered code was an exercise in understanding
        workflows and a good opportunity to retroactively create a requirements
        document. Even without a separate document, a well written test can
        function as a passable specification.`),m=T(),c=h("p"),l=w(`The same is true of unit tests but at a lower level. An E2E test
        provides value to a wider subset of stakeholders.`)},l(n){e=g(n,"P",{});var u=k(e);f=v(u,"VenueTube started as a "),F(i.$$.fragment,u),s=v(u,` script and evolved from there based on user feedback. There was never
        a formal plan or even workflow documentation.`),u.forEach(t),d=A(n),o=g(n,"P",{});var _=k(o);a=v(_,`Finding and eliminating uncovered code was an exercise in understanding
        workflows and a good opportunity to retroactively create a requirements
        document. Even without a separate document, a well written test can
        function as a passable specification.`),_.forEach(t),m=A(n),c=g(n,"P",{});var S=k(c);l=v(S,`The same is true of unit tests but at a lower level. An E2E test
        provides value to a wider subset of stakeholders.`),S.forEach(t)},m(n,u){p(n,e,u),$(e,f),j(i,e,null),$(e,s),p(n,d,u),p(n,o,u),$(o,a),p(n,m,u),p(n,c,u),$(c,l),r=!0},p:Y,i(n){r||(D(i.$$.fragment,n),r=!0)},o(n){U(i.$$.fragment,n),r=!1},d(n){n&&t(e),L(i),n&&t(d),n&&t(o),n&&t(m),n&&t(c)}}}function xt(P){let e,f,i,s,d;return{c(){e=h("p"),f=w(`Writing the test also helped catch cumbersome UX. Some workflows that
        seemed intuitive when written were challenging to test. In several cases
        those turned out to be real usability issues.`),i=T(),s=h("p"),d=w(`For example, I noticed some vestigial code that could only be exercised
        by signing in and navigating to a specific URL. I needed to remove the
        (effectively dead) code or find a way to make it more accessible.`)},l(o){e=g(o,"P",{});var a=k(e);f=v(a,`Writing the test also helped catch cumbersome UX. Some workflows that
        seemed intuitive when written were challenging to test. In several cases
        those turned out to be real usability issues.`),a.forEach(t),i=A(o),s=g(o,"P",{});var m=k(s);d=v(m,`For example, I noticed some vestigial code that could only be exercised
        by signing in and navigating to a specific URL. I needed to remove the
        (effectively dead) code or find a way to make it more accessible.`),m.forEach(t)},m(o,a){p(o,e,a),$(e,f),p(o,i,a),p(o,s,a),$(s,d)},p:Y,d(o){o&&t(e),o&&t(i),o&&t(s)}}}function Wt(P){let e,f,i,s,d;return{c(){e=h("p"),f=w(`It's possible to have blazing fast unit tests and horrible application
        performance. That's not the case with E2E testing.`),i=T(),s=h("p"),d=w(`Testing the entire app makes performance a pain point during
        development. Improvements benefit developers and end-users alike.`)},l(o){e=g(o,"P",{});var a=k(e);f=v(a,`It's possible to have blazing fast unit tests and horrible application
        performance. That's not the case with E2E testing.`),a.forEach(t),i=A(o),s=g(o,"P",{});var m=k(s);d=v(m,`Testing the entire app makes performance a pain point during
        development. Improvements benefit developers and end-users alike.`),m.forEach(t)},m(o,a){p(o,e,a),$(e,f),p(o,i,a),p(o,s,a),$(s,d)},p:Y,d(o){o&&t(e),o&&t(i),o&&t(s)}}}function Ht(P){let e,f,i,s,d,o,a,m,c;return s=new J({props:{title:"Retroactive Requirements",$$slots:{default:[Ct]},$$scope:{ctx:P}}}),o=new J({props:{title:"Awkward Workflows",$$slots:{default:[xt]},$$scope:{ctx:P}}}),m=new J({props:{title:"User and Developer Experience Alignment",$$slots:{default:[Wt]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`The main motivator for this project was to get the greatest amount of test
      coverage in the shortest amount of time. While that was a success, there
      were also some unexpected benefits.`),i=T(),M(s.$$.fragment),d=T(),M(o.$$.fragment),a=T(),M(m.$$.fragment)},l(l){e=g(l,"P",{});var r=k(e);f=v(r,`The main motivator for this project was to get the greatest amount of test
      coverage in the shortest amount of time. While that was a success, there
      were also some unexpected benefits.`),r.forEach(t),i=A(l),F(s.$$.fragment,l),d=A(l),F(o.$$.fragment,l),a=A(l),F(m.$$.fragment,l)},m(l,r){p(l,e,r),$(e,f),p(l,i,r),j(s,l,r),p(l,d,r),j(o,l,r),p(l,a,r),j(m,l,r),c=!0},p(l,r){const n={};r&512&&(n.$$scope={dirty:r,ctx:l}),s.$set(n);const u={};r&512&&(u.$$scope={dirty:r,ctx:l}),o.$set(u);const _={};r&512&&(_.$$scope={dirty:r,ctx:l}),m.$set(_)},i(l){c||(D(s.$$.fragment,l),D(o.$$.fragment,l),D(m.$$.fragment,l),c=!0)},o(l){U(s.$$.fragment,l),U(o.$$.fragment,l),U(m.$$.fragment,l),c=!1},d(l){l&&t(e),l&&t(i),L(s,l),l&&t(d),L(o,l),l&&t(a),L(m,l)}}}function Rt(P){let e,f;return{c(){e=h("p"),f=w(`VenueTube is a simple monolithic app with only a few external API
        integrations. I'm able to get through all existing workflows in about 90
        seconds. Your mileage may vary.`)},l(i){e=g(i,"P",{});var s=k(e);f=v(s,`VenueTube is a simple monolithic app with only a few external API
        integrations. I'm able to get through all existing workflows in about 90
        seconds. Your mileage may vary.`),s.forEach(t)},m(i,s){p(i,e,s),$(e,f)},p:Y,d(i){i&&t(e)}}}function Bt(P){let e;return{c(){e=w(`Many forms of test adequacy criteria have been tried, and will be tried
        in this world of faulty software. No one pretends that code coverage is
        perfect or all-wise. Indeed, it has been said that code coverage is the
        worst form of test adequacy criteria except for all those other forms
        that have been tried from time to time...`)},l(f){e=v(f,`Many forms of test adequacy criteria have been tried, and will be tried
        in this world of faulty software. No one pretends that code coverage is
        perfect or all-wise. Indeed, it has been said that code coverage is the
        worst form of test adequacy criteria except for all those other forms
        that have been tried from time to time...`)},m(f,i){p(f,e,i)},d(f){f&&t(e)}}}function Dt(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S,C,I,E,W;return s=new fe({props:{value:P[4]}}),S=new Ae({props:{author:"Winston Churchill, probably",$$slots:{default:[Bt]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`Is code coverage even a good measure of test suite adequacy? After all,
        this test yields 100% coverage for our sum function.`),i=T(),M(s.$$.fragment),d=T(),o=h("p"),a=w("The only information this test gives us is that "),m=h("code"),c=w("sum(1, 2);"),l=w(`
        doesn't throw an exception. Similarly, I didn't `),r=h("code"),n=w("assert"),u=w(` once.
        Instead, it relies on implicit assertions made by Playwright to proceed through
        the test. There is nothing stopping me from adding assertions but it won't
        improve code coverage.`),_=T(),M(S.$$.fragment),C=T(),I=h("p"),E=w(`Code coverage isn't perfect but I haven't found anything better. One
        non-obvious benefit is that there are two ways to increase it: add more
        tests or reduce the source lines that need testing. Targeting the latter
        can lead to a cleaner codebase.`)},l(b){e=g(b,"P",{});var x=k(e);f=v(x,`Is code coverage even a good measure of test suite adequacy? After all,
        this test yields 100% coverage for our sum function.`),x.forEach(t),i=A(b),F(s.$$.fragment,b),d=A(b),o=g(b,"P",{});var O=k(o);a=v(O,"The only information this test gives us is that "),m=g(O,"CODE",{});var V=k(m);c=v(V,"sum(1, 2);"),V.forEach(t),l=v(O,`
        doesn't throw an exception. Similarly, I didn't `),r=g(O,"CODE",{});var Q=k(r);n=v(Q,"assert"),Q.forEach(t),u=v(O,` once.
        Instead, it relies on implicit assertions made by Playwright to proceed through
        the test. There is nothing stopping me from adding assertions but it won't
        improve code coverage.`),O.forEach(t),_=A(b),F(S.$$.fragment,b),C=A(b),I=g(b,"P",{});var y=k(I);E=v(y,`Code coverage isn't perfect but I haven't found anything better. One
        non-obvious benefit is that there are two ways to increase it: add more
        tests or reduce the source lines that need testing. Targeting the latter
        can lead to a cleaner codebase.`),y.forEach(t)},m(b,x){p(b,e,x),$(e,f),p(b,i,x),j(s,b,x),p(b,d,x),p(b,o,x),$(o,a),$(o,m),$(m,c),$(o,l),$(o,r),$(r,n),$(o,u),p(b,_,x),j(S,b,x),p(b,C,x),p(b,I,x),$(I,E),W=!0},p(b,x){const O={};x&512&&(O.$$scope={dirty:x,ctx:b}),S.$set(O)},i(b){W||(D(s.$$.fragment,b),D(S.$$.fragment,b),W=!0)},o(b){U(s.$$.fragment,b),U(S.$$.fragment,b),W=!1},d(b){b&&t(e),b&&t(i),L(s,b),b&&t(d),b&&t(o),b&&t(_),L(S,b),b&&t(C),b&&t(I)}}}function Ut(P){let e,f,i,s,d,o,a,m,c,l,r,n;return{c(){e=h("p"),f=w(`The 100% mark is controversial and can be difficult to attain especially
        if you don't design for test from the start. I justify it with these two
        arguments:`),i=T(),s=h("ol"),d=h("li"),o=w("Any other number feels (more) arbitrary"),a=T(),m=h("li"),c=w("Ensuring that every line of code executes seems like a low bar"),l=T(),r=h("p"),n=w(`Since V8 actually returns coverage count per line, I'd even be inclined
        to go beyond 100% but need to give more thought to how that would work.`)},l(u){e=g(u,"P",{});var _=k(e);f=v(_,`The 100% mark is controversial and can be difficult to attain especially
        if you don't design for test from the start. I justify it with these two
        arguments:`),_.forEach(t),i=A(u),s=g(u,"OL",{});var S=k(s);d=g(S,"LI",{});var C=k(d);o=v(C,"Any other number feels (more) arbitrary"),C.forEach(t),a=A(S),m=g(S,"LI",{});var I=k(m);c=v(I,"Ensuring that every line of code executes seems like a low bar"),I.forEach(t),S.forEach(t),l=A(u),r=g(u,"P",{});var E=k(r);n=v(E,`Since V8 actually returns coverage count per line, I'd even be inclined
        to go beyond 100% but need to give more thought to how that would work.`),E.forEach(t)},m(u,_){p(u,e,_),$(e,f),p(u,i,_),p(u,s,_),$(s,d),$(d,o),$(s,a),$(s,m),$(m,c),p(u,l,_),p(u,r,_),$(r,n)},p:Y,d(u){u&&t(e),u&&t(i),u&&t(s),u&&t(l),u&&t(r)}}}function Mt(P){let e,f,i,s,d,o;return e=new J({props:{title:"",$$slots:{default:[Rt]},$$scope:{ctx:P}}}),i=new J({props:{title:"Test Suite Adequacy",$$slots:{default:[Dt]},$$scope:{ctx:P}}}),d=new J({props:{title:"100% Coverage",$$slots:{default:[Ut]},$$scope:{ctx:P}}}),{c(){M(e.$$.fragment),f=T(),M(i.$$.fragment),s=T(),M(d.$$.fragment)},l(a){F(e.$$.fragment,a),f=A(a),F(i.$$.fragment,a),s=A(a),F(d.$$.fragment,a)},m(a,m){j(e,a,m),p(a,f,m),j(i,a,m),p(a,s,m),j(d,a,m),o=!0},p(a,m){const c={};m&512&&(c.$$scope={dirty:m,ctx:a}),e.$set(c);const l={};m&512&&(l.$$scope={dirty:m,ctx:a}),i.$set(l);const r={};m&512&&(r.$$scope={dirty:m,ctx:a}),d.$set(r)},i(a){o||(D(e.$$.fragment,a),D(i.$$.fragment,a),D(d.$$.fragment,a),o=!0)},o(a){U(e.$$.fragment,a),U(i.$$.fragment,a),U(d.$$.fragment,a),o=!1},d(a){L(e,a),a&&t(f),L(i,a),a&&t(s),L(d,a)}}}function Ft(P){let e,f;return{c(){e=h("p"),f=w(`Splitting the test into independent workflows could improve isolation
        and reduce runtime through parallelization.`)},l(i){e=g(i,"P",{});var s=k(e);f=v(s,`Splitting the test into independent workflows could improve isolation
        and reduce runtime through parallelization.`),s.forEach(t)},m(i,s){p(i,e,s),$(e,f)},p:Y,d(i){i&&t(e)}}}function jt(P){let e,f;return{c(){e=h("p"),f=w(`Seeding the database could speed up certain workflows and reduce
        flakiness. In one case, my test started failing because randomly
        generated content contained the word "Holler" which is used in an
        element selector.`)},l(i){e=g(i,"P",{});var s=k(e);f=v(s,`Seeding the database could speed up certain workflows and reduce
        flakiness. In one case, my test started failing because randomly
        generated content contained the word "Holler" which is used in an
        element selector.`),s.forEach(t)},m(i,s){p(i,e,s),$(e,f)},p:Y,d(i){i&&t(e)}}}function Lt(P){let e,f;return{c(){e=h("p"),f=w(`Complementing E2E tests with unit tests focused on especially complex or
        sensitive operations. Many low-level functions that are only lightly
        exercised here would make great unit testing candidates.`)},l(i){e=g(i,"P",{});var s=k(e);f=v(s,`Complementing E2E tests with unit tests focused on especially complex or
        sensitive operations. Many low-level functions that are only lightly
        exercised here would make great unit testing candidates.`),s.forEach(t)},m(i,s){p(i,e,s),$(e,f)},p:Y,d(i){i&&t(e)}}}function Ot(P){let e,f,i,s,d,o,a,m,c,l,r,n;return a=new J({props:{title:"Decomposition",$$slots:{default:[Ft]},$$scope:{ctx:P}}}),c=new J({props:{title:"Database Setup",$$slots:{default:[jt]},$$scope:{ctx:P}}}),r=new J({props:{title:"Unit Testing",$$slots:{default:[Lt]},$$scope:{ctx:P}}}),{c(){e=h("p"),f=w(`I'm certainly not advocating the use of a single test to provide all of
      your quality assurance. That would be crazy... right?`),i=T(),s=h("p"),d=w("Here are some of the next steps I'll take to shore up my QA program."),o=T(),M(a.$$.fragment),m=T(),M(c.$$.fragment),l=T(),M(r.$$.fragment)},l(u){e=g(u,"P",{});var _=k(e);f=v(_,`I'm certainly not advocating the use of a single test to provide all of
      your quality assurance. That would be crazy... right?`),_.forEach(t),i=A(u),s=g(u,"P",{});var S=k(s);d=v(S,"Here are some of the next steps I'll take to shore up my QA program."),S.forEach(t),o=A(u),F(a.$$.fragment,u),m=A(u),F(c.$$.fragment,u),l=A(u),F(r.$$.fragment,u)},m(u,_){p(u,e,_),$(e,f),p(u,i,_),p(u,s,_),$(s,d),p(u,o,_),j(a,u,_),p(u,m,_),j(c,u,_),p(u,l,_),j(r,u,_),n=!0},p(u,_){const S={};_&512&&(S.$$scope={dirty:_,ctx:u}),a.$set(S);const C={};_&512&&(C.$$scope={dirty:_,ctx:u}),c.$set(C);const I={};_&512&&(I.$$scope={dirty:_,ctx:u}),r.$set(I)},i(u){n||(D(a.$$.fragment,u),D(c.$$.fragment,u),D(r.$$.fragment,u),n=!0)},o(u){U(a.$$.fragment,u),U(c.$$.fragment,u),U(r.$$.fragment,u),n=!1},d(u){u&&t(e),u&&t(i),u&&t(s),u&&t(o),L(a,u),u&&t(m),L(c,u),u&&t(l),L(r,u)}}}function Vt(P){let e,f,i,s,d,o,a,m;return{c(){e=h("p"),f=w(`If you are early on in development of your app, I'd recommend trying out
      uni-testing™️. It's a low-barrier way to focus on UX and catch potentially
      embarrassing issues before your users do.`),i=T(),s=h("p"),d=w(`Once you get some traction, decompose the test suite into a proper test
      pyramid including integration and unit tests.`),o=T(),a=h("p"),m=w(`In the meantime, tell anyone who'll listen that your application has 100%
      code coverage.`)},l(c){e=g(c,"P",{});var l=k(e);f=v(l,`If you are early on in development of your app, I'd recommend trying out
      uni-testing™️. It's a low-barrier way to focus on UX and catch potentially
      embarrassing issues before your users do.`),l.forEach(t),i=A(c),s=g(c,"P",{});var r=k(s);d=v(r,`Once you get some traction, decompose the test suite into a proper test
      pyramid including integration and unit tests.`),r.forEach(t),o=A(c),a=g(c,"P",{});var n=k(a);m=v(n,`In the meantime, tell anyone who'll listen that your application has 100%
      code coverage.`),n.forEach(t)},m(c,l){p(c,e,l),$(e,f),p(c,i,l),p(c,s,l),$(s,d),p(c,o,l),p(c,a,l),$(a,m)},p:Y,d(c){c&&t(e),c&&t(i),c&&t(s),c&&t(o),c&&t(a)}}}function Nt(P){let e,f,i,s,d,o,a,m,c,l,r,n,u,_,S,C,I,E,W,b,x,O,V,Q;return e=new ie({props:{title:"",$$slots:{default:[it]},$$scope:{ctx:P}}}),i=new ie({props:{title:"Unit Testing Woes",$$slots:{default:[ct]},$$scope:{ctx:P}}}),d=new ie({props:{title:"Goals",$$slots:{default:[gt]},$$scope:{ctx:P}}}),a=new ie({props:{title:"What about E2E?",$$slots:{default:[wt]},$$scope:{ctx:P}}}),c=new ie({props:{title:"Zero to One (hundred percent coverage)",$$slots:{default:[yt]},$$scope:{ctx:P}}}),r=new ie({props:{title:"Challenges",$$slots:{default:[It]},$$scope:{ctx:P}}}),u=new ie({props:{title:"Results",$$slots:{default:[qt]},$$scope:{ctx:P}}}),S=new ie({props:{title:"Unexpected Wins",$$slots:{default:[Ht]},$$scope:{ctx:P}}}),I=new ie({props:{title:"Caveats",$$slots:{default:[Mt]},$$scope:{ctx:P}}}),W=new ie({props:{title:"Next Steps",$$slots:{default:[Ot]},$$scope:{ctx:P}}}),x=new ie({props:{title:"Conclusion",$$slots:{default:[Vt]},$$scope:{ctx:P}}}),V=new Ke({props:{resources:[{href:"https://playwright.dev/docs/intro",label:"Playwright",type:"docs"},{href:"https://github.com/nodemailer/nodemailer",label:"Nodemailer",type:"package"},{href:"https://github.com/postalsys/imapflow",label:"ImapFlow",type:"package"},{href:"https://github.com/nodemailer/mailparser",label:"mailparser",type:"package"},{href:"https://kentcdodds.com/blog/write-tests",label:"Write tests. Not too many. Mostly integration.",type:"article"},{href:"https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html",label:"TestPyramid",type:"article"},{href:"https://martinfowler.com/bliki/TestPyramid.html",label:"Just Say No to More End-to-End Tests",type:"article"}]}}),{c(){M(e.$$.fragment),f=T(),M(i.$$.fragment),s=T(),M(d.$$.fragment),o=T(),M(a.$$.fragment),m=T(),M(c.$$.fragment),l=T(),M(r.$$.fragment),n=T(),M(u.$$.fragment),_=T(),M(S.$$.fragment),C=T(),M(I.$$.fragment),E=T(),M(W.$$.fragment),b=T(),M(x.$$.fragment),O=T(),M(V.$$.fragment)},l(y){F(e.$$.fragment,y),f=A(y),F(i.$$.fragment,y),s=A(y),F(d.$$.fragment,y),o=A(y),F(a.$$.fragment,y),m=A(y),F(c.$$.fragment,y),l=A(y),F(r.$$.fragment,y),n=A(y),F(u.$$.fragment,y),_=A(y),F(S.$$.fragment,y),C=A(y),F(I.$$.fragment,y),E=A(y),F(W.$$.fragment,y),b=A(y),F(x.$$.fragment,y),O=A(y),F(V.$$.fragment,y)},m(y,R){j(e,y,R),p(y,f,R),j(i,y,R),p(y,s,R),j(d,y,R),p(y,o,R),j(a,y,R),p(y,m,R),j(c,y,R),p(y,l,R),j(r,y,R),p(y,n,R),j(u,y,R),p(y,_,R),j(S,y,R),p(y,C,R),j(I,y,R),p(y,E,R),j(W,y,R),p(y,b,R),j(x,y,R),p(y,O,R),j(V,y,R),Q=!0},p(y,R){const te={};R&512&&(te.$$scope={dirty:R,ctx:y}),e.$set(te);const H={};R&512&&(H.$$scope={dirty:R,ctx:y}),i.$set(H);const z={};R&512&&(z.$$scope={dirty:R,ctx:y}),d.$set(z);const K={};R&512&&(K.$$scope={dirty:R,ctx:y}),a.$set(K);const oe={};R&512&&(oe.$$scope={dirty:R,ctx:y}),c.$set(oe);const B={};R&512&&(B.$$scope={dirty:R,ctx:y}),r.$set(B);const N={};R&512&&(N.$$scope={dirty:R,ctx:y}),u.$set(N);const Z={};R&512&&(Z.$$scope={dirty:R,ctx:y}),S.$set(Z);const ee={};R&512&&(ee.$$scope={dirty:R,ctx:y}),I.$set(ee);const ne={};R&512&&(ne.$$scope={dirty:R,ctx:y}),W.$set(ne);const se={};R&512&&(se.$$scope={dirty:R,ctx:y}),x.$set(se)},i(y){Q||(D(e.$$.fragment,y),D(i.$$.fragment,y),D(d.$$.fragment,y),D(a.$$.fragment,y),D(c.$$.fragment,y),D(r.$$.fragment,y),D(u.$$.fragment,y),D(S.$$.fragment,y),D(I.$$.fragment,y),D(W.$$.fragment,y),D(x.$$.fragment,y),D(V.$$.fragment,y),Q=!0)},o(y){U(e.$$.fragment,y),U(i.$$.fragment,y),U(d.$$.fragment,y),U(a.$$.fragment,y),U(c.$$.fragment,y),U(r.$$.fragment,y),U(u.$$.fragment,y),U(S.$$.fragment,y),U(I.$$.fragment,y),U(W.$$.fragment,y),U(x.$$.fragment,y),U(V.$$.fragment,y),Q=!1},d(y){L(e,y),y&&t(f),L(i,y),y&&t(s),L(d,y),y&&t(o),L(a,y),y&&t(m),L(c,y),y&&t(l),L(r,y),y&&t(n),L(u,y),y&&t(_),L(S,y),y&&t(C),L(I,y),y&&t(E),L(W,y),y&&t(b),L(x,y),y&&t(O),L(V,y)}}}function Gt(P){let e;return{c(){e=w(`Playwright docs advise writing fewer, longer tests. I follow that advice to
    its logical conclusion.`)},l(f){e=v(f,`Playwright docs advise writing fewer, longer tests. I follow that advice to
    its logical conclusion.`)},m(f,i){p(f,e,i)},d(f){f&&t(e)}}}function zt(P){let e,f,i,s,d,o,a,m,c,l;return document.title=e=be,c=new Ze({props:{title:be,date:P[0],$$slots:{tldr:[Gt],default:[Nt]},$$scope:{ctx:P}}}),{c(){f=h("meta"),i=h("meta"),s=h("meta"),d=h("meta"),o=h("meta"),a=h("meta"),m=T(),M(c.$$.fragment),this.h()},l(r){const n=Xe("svelte-1fkt6kq",document.head);f=g(n,"META",{name:!0,content:!0}),i=g(n,"META",{property:!0,content:!0}),s=g(n,"META",{property:!0,content:!0}),d=g(n,"META",{property:!0,content:!0}),o=g(n,"META",{property:!0,content:!0}),a=g(n,"META",{property:!0,content:!0}),n.forEach(t),m=A(r),F(c.$$.fragment,r),this.h()},h(){X(f,"name","description"),X(f,"content",Ve),X(i,"property","og:title"),X(i,"content",be),X(s,"property","og:url"),X(s,"content","https://neil.macmunn.com/posts/uni-testing"),X(d,"property","og:description"),X(d,"content",Ve),X(o,"property","og:image"),X(o,"content","https://neil.macmunn.com/playwright-process.png"),X(a,"property","og:type"),X(a,"content","article")},m(r,n){$(document.head,f),$(document.head,i),$(document.head,s),$(document.head,d),$(document.head,o),$(document.head,a),p(r,m,n),j(c,r,n),l=!0},p(r,[n]){(!l||n&0)&&e!==(e=be)&&(document.title=e);const u={};n&512&&(u.$$scope={dirty:n,ctx:r}),c.$set(u)},i(r){l||(D(c.$$.fragment,r),l=!0)},o(r){U(c.$$.fragment,r),l=!1},d(r){t(f),t(i),t(s),t(d),t(o),t(a),r&&t(m),L(c,r)}}}const be="Uni-Testing 101",Ve="Getting 100% code coverage with a single Playwright test";function Jt(P){return[new Date("April 3, 2023"),`d8eb580 fix flaky test
f744d31 fix flaky test
f88dd2d fix flaky test
0c27836 fix flaky test
b6f8bfa fix flaky test
3e42121 fix flaky test
5e414d7 game changing feature`,`function sum(a: number, b: number) {
  return a + b;
}`,`test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});`,`test('adds 1 + 2 to equal 3', () => {
  sum(1, 2);
});`,`test("app", () => {
  expect(app()).to.bePerfect();
});`,`export async function run() {
  const browser = await chromium.launch({ headless: false });
  const context = await browser.newContext();

  // start trace recording
  await context.tracing.start({ screenshots: true, snapshots: true });

  // monkey patch context.newPage to start coverage
  const newPage = context.newPage.bind(context);
  context.newPage = async () => {
    const page = await newPage();
    const close = page.close.bind(page);
    // monkey patch page.close to stop coverage
    page.close = async () => {
      const coverage = await page.coverage.stopJSCoverage();
      // not shown: aggregate coverage
      await close();
    };
    await page.coverage.startJSCoverage({ resetOnNavigation: false });
    return page;
  };

  try {
    await test(context);
  } catch (e) {
    console.error(e);
  }

  // stop trace recording
  await context.tracing.stop({ path: "trace.zip" });

  const done = context.pages().map(async (page) => {
    const coverage = await page.coverage.stopJSCoverage();
    // not shown: aggregate coverage
    // start the test generator
    return page.pause();
  });
  await Promise.all(done);
  context.close();
  browser.close();
}`,`export async function test(context: BrowserContext) {
  const page = await context.newPage();
  await page.goto(APP_URL);
}`,`export async function test(context: BrowserContext) {
  const page = await context.newPage();
  const searchInput = page.getByPlaceholder("Search a venue or city...");
  const searchContainer = page.locator("#search-container");
  const clearButton = searchContainer.locator('[uk-icon="close"]');

  log("Load home");
  await page.goto("http://localhost:5173", { waitUntil: "networkidle" });

  log("Fill and clear the search input");
  await searchInput.fill("williamsburg");
  await searchInput.fill("");
  await searchInput.fill("williamsburg");
  await clearButton.click();
  // more steps
}`]}class Zt extends Ie{constructor(e){super(),Pe(this,e,Jt,zt,Te,{})}}export{Zt as default};
